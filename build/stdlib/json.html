<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content="欢迎使用Teadocs文档生成系统"><meta name="keywords" content="teadocs, 文档生成器"><title>JSON 对象 - 阮一峰的JavaScript教程</title><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script src="https://cdn.bootcss.com/socket.io/2.1.1/socket.io.js"></script><script>window._CONST={THEME_DIR:"{{_CONST.THEME_DIR}}"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>阮一峰的JavaScript教程</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value="" height="100%"></div><html><head></head><body><ul class="tea-menu-list"><li><a href="/index.html" title="关于" class="">关于</a></li><li><a href="/preface.html" title="阮一峰前言" class="">阮一峰前言</a></li><li><a title="教程" class="active">教程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="入门篇" class="">入门篇<i class="fa fa-angle-down"></i></a><ul><li><a href="/basic/introduction.html" title="导论" class="">导论</a></li><li><a href="/basic/history.html" title="历史" class="">历史</a></li><li><a href="/basic/grammar.html" title="基本语法" class="">基本语法</a></li></ul></li><li><a title="数据类型" class="">数据类型<i class="fa fa-angle-down"></i></a><ul><li><a href="/types/general.html" title="概述" class="">概述</a></li><li><a href="/types/null-undefined-boolean.html" title="null，undefined和布尔值" class="">null，undefined和布尔值</a></li><li><a href="/types/number.html" title="数值" class="">数值</a></li><li><a href="/types/string.html" title="字符串" class="">字符串</a></li><li><a href="/types/object.html" title="对象" class="">对象</a></li><li><a href="/types/function.html" title="函数" class="">函数</a></li><li><a href="/types/array.html" title="数组" class="">数组</a></li></ul></li><li><a title="运算符" class="">运算符<i class="fa fa-angle-down"></i></a><ul><li><a href="/operators/arithmetic.html" title="算术运算符" class="">算术运算符</a></li><li><a href="/operators/comparison.html" title="比较运算符" class="">比较运算符</a></li><li><a href="/operators/boolean.html" title="布尔运算符" class="">布尔运算符</a></li><li><a href="/operators/bit.html" title="二进制位运算符" class="">二进制位运算符</a></li><li><a href="/operators/priority.html" title="其他运算符，运算顺序" class="">其他运算符，运算顺序</a></li></ul></li><li><a title="语法专题" class="">语法专题<i class="fa fa-angle-down"></i></a><ul><li><a href="/features/conversion.html" title="数据类型的转换" class="">数据类型的转换</a></li><li><a href="/features/error.html" title="错误处理机制" class="">错误处理机制</a></li><li><a href="/features/style.html" title="编程风格" class="">编程风格</a></li><li><a href="/features/console.html" title="console 对象与控制台" class="">console 对象与控制台</a></li></ul></li><li><a title="标准库" class="active">标准库<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/stdlib/object.html" title="Object对象" class="">Object对象</a></li><li><a href="/stdlib/attributes.html" title="属性描述对象" class="">属性描述对象</a></li><li><a href="/stdlib/array.html" title="Array 对象" class="">Array 对象</a></li><li><a href="/stdlib/wrapper.html" title="包装对象" class="">包装对象</a></li><li><a href="/stdlib/boolean.html" title="Boolean 对象" class="">Boolean 对象</a></li><li><a href="/stdlib/number.html" title="Number 对象" class="">Number 对象</a></li><li><a href="/stdlib/string.html" title="String 对象" class="">String 对象</a></li><li><a href="/stdlib/math.html" title="Math 对象" class="">Math 对象</a></li><li><a href="/stdlib/date.html" title="Date 对象" class="">Date 对象</a></li><li><a href="/stdlib/regexp.html" title="RegExp 对象" class="">RegExp 对象</a></li><li><a href="/stdlib/json.html" title="JSON 对象" class="active">JSON 对象</a></li></ul></li><li><a title="面向对象编程">面向对象编程<i class="fa fa-angle-down"></i></a><ul><li><a href="/oop/new.html" title="实例对象与 new 命令">实例对象与 new 命令</a></li><li><a href="/oop/this.html" title="this 关键字">this 关键字</a></li><li><a href="/oop/prototype.html" title="对象的继承">对象的继承</a></li><li><a href="/oop/object.html" title="Object 对象的相关方法">Object 对象的相关方法</a></li><li><a href="/oop/strict.html" title="Object 对象的相关方法">Object 对象的相关方法</a></li></ul></li><li><a title="异步操作">异步操作<i class="fa fa-angle-down"></i></a><ul><li><a href="/async/general.html" title="概述">概述</a></li><li><a href="/async/timer.html" title="定时器">定时器</a></li><li><a href="/async/promise.html" title="Promise 对象">Promise 对象</a></li></ul></li><li><a title="DOM">DOM<i class="fa fa-angle-down"></i></a><ul><li><a href="/dom/general.html" title="概述">概述</a></li><li><a href="/dom/node.html" title="Node 接口">Node 接口</a></li><li><a href="/dom/nodelist.html" title="NodeList 接口，HTMLCollection 接口">NodeList 接口，HTMLCollection 接口</a></li><li><a href="/dom/parentnode.html" title="ParentNode 接口，ChildNode 接口">ParentNode 接口，ChildNode 接口</a></li><li><a href="/dom/document.html" title="Document 节点">Document 节点</a></li><li><a href="/dom/element.html" title="Element 节点">Element 节点</a></li><li><a href="/dom/attributes.html" title="属性的操作">属性的操作</a></li><li><a href="/dom/text.html" title="Text 节点和 DocumentFragment 节点">Text 节点和 DocumentFragment 节点</a></li><li><a href="/dom/mutationobserver.html" title="Mutation Observer API">Mutation Observer API</a></li></ul></li><li><a title="事件">事件<i class="fa fa-angle-down"></i></a><ul><li><a href="/events/eventtarget.html" title="EventTarget 接口">EventTarget 接口</a></li><li><a href="/events/model.html" title="事件模型">事件模型</a></li><li><a href="/events/event.html" title="Event 对象">Event 对象</a></li><li><a href="/events/mouse.html" title="鼠标事件">鼠标事件</a></li><li><a href="/events/keyboard.html" title="键盘事件">键盘事件</a></li><li><a href="/events/progress.html" title="进度事件">进度事件</a></li><li><a href="/events/form.html" title="表单事件">表单事件</a></li><li><a href="/events/touch.html" title="触摸事件">触摸事件</a></li><li><a href="/events/drag.html" title="拖拉事件">拖拉事件</a></li><li><a href="/events/common.html" title="其他常见事件">其他常见事件</a></li><li><a href="/events/globaleventhandlers.html" title="拖拉事件">拖拉事件</a></li></ul></li><li><a title="浏览器模型">浏览器模型<i class="fa fa-angle-down"></i></a><ul><li><a href="/bom/engine.html" title="浏览器环境概述">浏览器环境概述</a></li><li><a href="/bom/window.html" title="window 对象">window 对象</a></li><li><a href="/bom/navigator.html" title="Navigator 对象，Screen 对象">Navigator 对象，Screen 对象</a></li><li><a href="/bom/cookie.html" title="cookie">cookie</a></li><li><a href="/bom/xmlhttprequest.html" title="XMLHttpRequest 对象">XMLHttpRequest 对象</a></li><li><a href="/bom/same-origin.html" title="同源限制">同源限制</a></li><li><a href="/bom/cors.html" title="CORS 通信">CORS 通信</a></li><li><a href="/bom/storage.html" title="Storage 接口">Storage 接口</a></li><li><a href="/bom/history.html" title="History 对象">History 对象</a></li><li><a href="/bom/location.html" title="Location 对象，URL 对象，URLSearchParams 对象">Location 对象，URL 对象，URLSearchParams 对象</a></li><li><a href="/bom/arraybuffer.html" title="ArrayBuffer 对象，Blob 对象">ArrayBuffer 对象，Blob 对象</a></li><li><a href="/bom/file.html" title="File 对象，FileList 对象，FileReader 对象">File 对象，FileList 对象，FileReader 对象</a></li><li><a href="/bom/form.html" title="表单，FormData 对象">表单，FormData 对象</a></li><li><a href="/bom/indexeddb.html" title="IndexedDB API">IndexedDB API</a></li><li><a href="/bom/webworker.html" title="Web Worker">Web Worker</a></li></ul></li><li><a title="附录：网页元素接口">附录：网页元素接口<i class="fa fa-angle-down"></i></a><ul><li><a href="/elements/a.html" title="a 元素">a 元素</a></li><li><a href="/elements/image.html" title="img 元素">img 元素</a></li><li><a href="/elements/form.html" title="form 元素">form 元素</a></li><li><a href="/elements/input.html" title="input 元素">input 元素</a></li><li><a href="/elements/button.html" title="button 元素">button 元素</a></li><li><a href="/elements/option.html" title="option 元素">option 元素</a></li><li><a href="/elements/video.html" title="video，audio">video，audio</a></li></ul></li></ul></li></ul></body></html><div class="tea-version"><p>version: v0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>JSON 对象</span></h3></div><div class="tea-container"><div class="markdown-body"><h1><a href="#JSON-对象" class="header-anchor">#</a> <span>JSON 对象</span></h1><h2><a href="#JSON-格式" class="header-anchor">#</a> <span>JSON 格式</span></h2><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p><p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。</p><p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。</p><p>JSON 对值的类型和格式有严格的规定。</p><blockquote><ol><li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p></li><li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p></li><li><p>字符串必须使用双引号表示，不能使用单引号。</p></li><li><p>对象的键名必须放在双引号里面。</p></li><li><p>数组或对象最后一个成员的后面，不能加逗号。</p></li></ol></blockquote><p>以下都是合法的 JSON。</p><pre class="prettyprint language-javascript"><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

{ &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3 }

{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;] }

[ { &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;} ]</code></pre><p>以下都是不合法的 JSON。</p><pre class="prettyprint language-javascript"><code>{ name: &quot;张三&quot;, &#039;age&#039;: 32 }  // 属性名必须使用双引号

[32, 64, 128, 0xFFF] // 不能使用十六进制值

{ &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: undefined } // 不能使用 undefined

{ &quot;name&quot;: &quot;张三&quot;,
  &quot;birthday&quot;: new Date(&#039;Fri, 26 Aug 2011 07:13:10 GMT&#039;),
  &quot;getName&quot;: function () {
      return this.name;
  }
} // 属性值不能使用函数和日期对象</code></pre><p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值。</p><h2><a href="#JSON-对象" class="header-anchor">#</a> <span>JSON 对象</span></h2><p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>。</p><h2><a href="#JSON.stringify()" class="header-anchor">#</a> <span>JSON.stringify()</span></h2><h3><a href="#基本用法" class="header-anchor">#</a> <span>基本用法</span></h3><p><code>JSON.stringify</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse</code>方法还原。</p><pre class="prettyprint language-javascript"><code>JSON.stringify(&#039;abc&#039;) // &quot;&quot;abc&quot;&quot;
JSON.stringify(1) // &quot;1&quot;
JSON.stringify(false) // &quot;false&quot;
JSON.stringify([]) // &quot;[]&quot;
JSON.stringify({}) // &quot;{}&quot;

JSON.stringify([1, &quot;false&quot;, false])
// &#039;[1,&quot;false&quot;,false]&#039;

JSON.stringify({ name: &quot;张三&quot; })
// &#039;{&quot;name&quot;:&quot;张三&quot;}&#039;</code></pre><p>上面代码将各种类型的值，转成 JSON 字符串。</p><p>注意，对于原始类型的字符串，转换结果会带双引号。</p><pre class="prettyprint language-javascript"><code>JSON.stringify(&#039;foo&#039;) === &quot;foo&quot; // false
JSON.stringify(&#039;foo&#039;) === &quot;\&quot;foo\&quot;&quot; // true</code></pre><p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo&quot;\&quot;</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值。</p><pre class="prettyprint language-javascript"><code>JSON.stringify(false) // &quot;false&quot;
JSON.stringify(&#039;false&#039;) // &quot;\&quot;false\&quot;&quot;</code></pre><p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串。</p><p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify</code>过滤。</p><pre class="prettyprint language-javascript"><code>var obj = {
  a: undefined,
  b: function () {}
};

JSON.stringify(obj) // &quot;{}&quot;</code></pre><p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤。</p><p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</p><pre class="prettyprint language-javascript"><code>var arr = [undefined, function () {}];
JSON.stringify(arr) // &quot;[null,null]&quot;</code></pre><p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>。</p><p>正则对象会被转成空对象。</p><pre class="prettyprint language-javascript"><code>JSON.stringify(/foo/) // &quot;{}&quot;</code></pre><p><code>JSON.stringify</code>方法会忽略对象的不可遍历属性。</p><pre class="prettyprint language-javascript"><code>var obj = {};
Object.defineProperties(obj, {
  &#039;foo&#039;: {
    value: 1,
    enumerable: true
  },
  &#039;bar&#039;: {
    value: 2,
    enumerable: false
  }
});

JSON.stringify(obj); // &quot;{&quot;foo&quot;:1}&quot;</code></pre><p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性。</p><h3><a href="#第二个参数" class="header-anchor">#</a> <span>第二个参数</span></h3><p><code>JSON.stringify</code>方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</p><pre class="prettyprint language-javascript"><code>var obj = {
  &#039;prop1&#039;: &#039;value1&#039;,
  &#039;prop2&#039;: &#039;value2&#039;,
  &#039;prop3&#039;: &#039;value3&#039;
};

var selectedProperties = [&#039;prop1&#039;, &#039;prop2&#039;];

JSON.stringify(obj, selectedProperties)
// &quot;{&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;}&quot;</code></pre><p>上面代码中，<code>JSON.stringify</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性。</p><p>这个类似白名单的数组，只对对象的属性有效，对数组无效。</p><pre class="prettyprint language-javascript"><code>JSON.stringify([&#039;a&#039;, &#039;b&#039;], [&#039;0&#039;])
// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;

JSON.stringify({0: &#039;a&#039;, 1: &#039;b&#039;}, [&#039;0&#039;])
// &quot;{&quot;0&quot;:&quot;a&quot;}&quot;</code></pre><p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效。</p><p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify</code>的返回值。</p><pre class="prettyprint language-javascript"><code>function f(key, value) {
  if (typeof value === &quot;number&quot;) {
    value = 2 * value;
  }
  return value;
}

JSON.stringify({ a: 1, b: 2 }, f)
// &#039;{&quot;a&quot;: 2,&quot;b&quot;: 4}&#039;</code></pre><p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以<code>2</code>，否则就原样返回。</p><p>注意，这个处理函数是递归处理所有的键。</p><pre class="prettyprint language-javascript"><code>var o = {a: {b: 1}};

function f(key, value) {
  console.log(&quot;[&quot;+ key +&quot;]:&quot; + value);
  return value;
}

JSON.stringify(o, f)
// []:[object Object]
// [a]:[object Object]
// [b]:1
// &#039;{&quot;a&quot;:{&quot;b&quot;:1}}&#039;</code></pre><p>上面代码中，对象<code>o</code>一共会被<code>f</code>函数处理三次，最后那行是<code>JSON.stringify</code>的输出。第一次键名为空，键值是整个对象<code>o</code>；第二次键名为<code>a</code>，键值是<code>{b: 1}</code>；第三次键名为<code>b</code>，键值为1。</p><p>递归处理中，每一次处理的对象，都是前一次返回的值。</p><pre class="prettyprint language-javascript"><code>var o = {a: 1};

function f(key, value) {
  if (typeof value === &#039;object&#039;) {
    return {b: 2};
  }
  return value * 2;
}

JSON.stringify(o, f)
// &quot;{&quot;b&quot;: 4}&quot;</code></pre><p>上面代码中，<code>f</code>函数修改了对象<code>o</code>，接着<code>JSON.stringify</code>方法就递归处理修改后的对象<code>o</code>。</p><p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p><pre class="prettyprint language-javascript"><code>function f(key, value) {
  if (typeof(value) === &quot;string&quot;) {
    return undefined;
  }
  return value;
}

JSON.stringify({ a: &quot;abc&quot;, b: 123 }, f)
// &#039;{&quot;b&quot;: 123}&#039;</code></pre><p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了。</p><h3><a href="#第三个参数" class="header-anchor">#</a> <span>第三个参数</span></h3><p><code>JSON.stringify</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</p><pre class="prettyprint language-javascript"><code>JSON.stringify({ p1: 1, p2: 2 }, null, 2);
/*
&quot;{
  &quot;p1&quot;: 1,
  &quot;p2&quot;: 2
}&quot;
*/

JSON.stringify({ p1:1, p2:2 }, null, &#039;|-&#039;);
/*
&quot;{
|-&quot;p1&quot;: 1,
|-&quot;p2&quot;: 2
}&quot;
*/</code></pre><h3><a href="#参数对象的-toJSON-方法" class="header-anchor">#</a> <span>参数对象的 toJSON 方法</span></h3><p>如果参数对象有自定义的<code>toJSON</code>方法，那么<code>JSON.stringify</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p><p>下面是一个普通的对象。</p><pre class="prettyprint language-javascript"><code>var user = {
  firstName: &#039;三&#039;,
  lastName: &#039;张&#039;,

  get fullName(){
    return this.lastName + this.firstName;
  }
};

JSON.stringify(user)
// &quot;{&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;}&quot;</code></pre><p>现在，为这个对象加上<code>toJSON</code>方法。</p><pre class="prettyprint language-javascript"><code>var user = {
  firstName: &#039;三&#039;,
  lastName: &#039;张&#039;,

  get fullName(){
    return this.lastName + this.firstName;
  },

  toJSON: function () {
    return {
      name: this.lastName + this.firstName
    };
  }
};

JSON.stringify(user)
// &quot;{&quot;name&quot;:&quot;张三&quot;}&quot;</code></pre><p>上面代码中，<code>JSON.stringify</code>发现参数对象有<code>toJSON</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。</p><p><code>Date</code>对象就有一个自己的<code>toJSON</code>方法。</p><pre class="prettyprint language-javascript"><code>var date = new Date(&#039;2015-01-01&#039;);
date.toJSON() // &quot;2015-01-01T00:00:00.000Z&quot;
JSON.stringify(date) // &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</code></pre><p>上面代码中，<code>JSON.stringify</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON</code>方法，将该方法的返回值作为参数。</p><p><code>toJSON</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify</code>默认不能转换正则对象，但是设置了<code>toJSON</code>方法以后，就可以转换正则对象了。</p><pre class="prettyprint language-javascript"><code>var obj = {
  reg: /foo/
};

// 不设置 toJSON 方法时
JSON.stringify(obj) // &quot;{&quot;reg&quot;:{}}&quot;

// 设置 toJSON 方法时
RegExp.prototype.toJSON = RegExp.prototype.toString;
JSON.stringify(/foo/) // &quot;&quot;/foo/&quot;&quot;</code></pre><p>上面代码在正则对象的原型上面部署了<code>toJSON</code>方法，将其指向<code>toString</code>方法，因此遇到转换成<code>JSON</code>时，正则对象就先调用<code>toJSON</code>方法转为字符串，然后再被<code>JSON.stingify</code>方法处理。</p><h2><a href="#JSON.parse()" class="header-anchor">#</a> <span>JSON.parse()</span></h2><p><code>JSON.parse</code>方法用于将 JSON 字符串转换成对应的值。</p><pre class="prettyprint language-javascript"><code>JSON.parse(&#039;{}&#039;) // {}
JSON.parse(&#039;true&#039;) // true
JSON.parse(&#039;&quot;foo&quot;&#039;) // &quot;foo&quot;
JSON.parse(&#039;[1, 5, &quot;false&quot;]&#039;) // [1, 5, &quot;false&quot;]
JSON.parse(&#039;null&#039;) // null

var o = JSON.parse(&#039;{&quot;name&quot;: &quot;张三&quot;}&#039;);
o.name // 张三</code></pre><p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse</code>方法将报错。</p><pre class="prettyprint language-javascript"><code>JSON.parse(&quot;&#039;String&#039;&quot;) // illegal single quotes
// SyntaxError: Unexpected token ILLEGAL</code></pre><p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错。</p><p>为了处理解析错误，可以将<code>JSON.parse</code>方法放在<code>try...catch</code>代码块中。</p><pre class="prettyprint language-javascript"><code>try {
  JSON.parse(&quot;&#039;String&#039;&quot;);
} catch(e) {
  console.log(&#039;parsing error&#039;);
}</code></pre><p><code>JSON.parse</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify</code>方法类似。</p><pre class="prettyprint language-javascript"><code>function f(key, value) {
  if (key === &#039;a&#039;) {
    return value + 10;
  }
  return value;
}

JSON.parse(&#039;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#039;, f)
// {a: 11, b: 2}</code></pre><p>上面代码中，<code>JSON.parse</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10。</p><h2><a href="#参考链接" class="header-anchor">#</a> <span>参考链接</span></h2><ul><li>MDN, <a href="https://developer.mozilla.org/en-US/docs/Using_native_JSON">Using native JSON</a></li><li>MDN, <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a></li><li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2011/08/json-api.html">JavaScript’s JSON API</a></li><li>Jim Cowart, <a href="http://freshbrewedcode.com/jimcowart/2013/01/29/what-you-might-not-know-about-json-stringify/">What You Might Not Know About JSON.stringify()</a></li><li>Marco Rogers polotek, <a href="http://docs.nodejitsu.com/articles/javascript-conventions/what-is-json">What is JSON?</a></li></ul></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script></body></html>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
