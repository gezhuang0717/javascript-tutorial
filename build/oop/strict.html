<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content="欢迎使用Teadocs文档生成系统"><meta name="keywords" content="teadocs, 文档生成器"><title>Object 对象的相关方法 - 阮一峰的JavaScript教程</title><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script src="https://cdn.bootcss.com/socket.io/2.1.1/socket.io.js"></script><script>window._CONST={THEME_DIR:"{{_CONST.THEME_DIR}}"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>阮一峰的JavaScript教程</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value="" height="100%"></div><html><head></head><body><ul class="tea-menu-list"><li><a href="/index.html" title="关于" class="">关于</a></li><li><a href="/preface.html" title="阮一峰前言" class="">阮一峰前言</a></li><li><a title="教程" class="active">教程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="入门篇" class="">入门篇<i class="fa fa-angle-down"></i></a><ul><li><a href="/basic/introduction.html" title="导论" class="">导论</a></li><li><a href="/basic/history.html" title="历史" class="">历史</a></li><li><a href="/basic/grammar.html" title="基本语法" class="">基本语法</a></li></ul></li><li><a title="数据类型" class="">数据类型<i class="fa fa-angle-down"></i></a><ul><li><a href="/types/general.html" title="概述" class="">概述</a></li><li><a href="/types/null-undefined-boolean.html" title="null，undefined和布尔值" class="">null，undefined和布尔值</a></li><li><a href="/types/number.html" title="数值" class="">数值</a></li><li><a href="/types/string.html" title="字符串" class="">字符串</a></li><li><a href="/types/object.html" title="对象" class="">对象</a></li><li><a href="/types/function.html" title="函数" class="">函数</a></li><li><a href="/types/array.html" title="数组" class="">数组</a></li></ul></li><li><a title="运算符" class="">运算符<i class="fa fa-angle-down"></i></a><ul><li><a href="/operators/arithmetic.html" title="算术运算符" class="">算术运算符</a></li><li><a href="/operators/comparison.html" title="比较运算符" class="">比较运算符</a></li><li><a href="/operators/boolean.html" title="布尔运算符" class="">布尔运算符</a></li><li><a href="/operators/bit.html" title="二进制位运算符" class="">二进制位运算符</a></li><li><a href="/operators/priority.html" title="其他运算符，运算顺序" class="">其他运算符，运算顺序</a></li></ul></li><li><a title="语法专题" class="">语法专题<i class="fa fa-angle-down"></i></a><ul><li><a href="/features/conversion.html" title="数据类型的转换" class="">数据类型的转换</a></li><li><a href="/features/error.html" title="错误处理机制" class="">错误处理机制</a></li><li><a href="/features/style.html" title="编程风格" class="">编程风格</a></li><li><a href="/features/console.html" title="console 对象与控制台" class="">console 对象与控制台</a></li></ul></li><li><a title="标准库" class="">标准库<i class="fa fa-angle-down"></i></a><ul><li><a href="/stdlib/object.html" title="Object对象" class="">Object对象</a></li><li><a href="/stdlib/attributes.html" title="属性描述对象" class="">属性描述对象</a></li><li><a href="/stdlib/array.html" title="Array 对象" class="">Array 对象</a></li><li><a href="/stdlib/wrapper.html" title="包装对象" class="">包装对象</a></li><li><a href="/stdlib/boolean.html" title="Boolean 对象" class="">Boolean 对象</a></li><li><a href="/stdlib/number.html" title="Number 对象" class="">Number 对象</a></li><li><a href="/stdlib/string.html" title="String 对象" class="">String 对象</a></li><li><a href="/stdlib/math.html" title="Math 对象" class="">Math 对象</a></li><li><a href="/stdlib/date.html" title="Date 对象" class="">Date 对象</a></li><li><a href="/stdlib/regexp.html" title="RegExp 对象" class="">RegExp 对象</a></li><li><a href="/stdlib/json.html" title="JSON 对象" class="">JSON 对象</a></li></ul></li><li><a title="面向对象编程" class="active">面向对象编程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/oop/new.html" title="实例对象与 new 命令" class="">实例对象与 new 命令</a></li><li><a href="/oop/this.html" title="this 关键字" class="">this 关键字</a></li><li><a href="/oop/prototype.html" title="对象的继承" class="">对象的继承</a></li><li><a href="/oop/object.html" title="Object 对象的相关方法" class="">Object 对象的相关方法</a></li><li><a href="/oop/strict.html" title="Object 对象的相关方法" class="active">Object 对象的相关方法</a></li></ul></li><li><a title="异步操作">异步操作<i class="fa fa-angle-down"></i></a><ul><li><a href="/async/general.html" title="概述">概述</a></li><li><a href="/async/timer.html" title="定时器">定时器</a></li><li><a href="/async/promise.html" title="Promise 对象">Promise 对象</a></li></ul></li><li><a title="DOM">DOM<i class="fa fa-angle-down"></i></a><ul><li><a href="/dom/general.html" title="概述">概述</a></li><li><a href="/dom/node.html" title="Node 接口">Node 接口</a></li><li><a href="/dom/nodelist.html" title="NodeList 接口，HTMLCollection 接口">NodeList 接口，HTMLCollection 接口</a></li><li><a href="/dom/parentnode.html" title="ParentNode 接口，ChildNode 接口">ParentNode 接口，ChildNode 接口</a></li><li><a href="/dom/document.html" title="Document 节点">Document 节点</a></li><li><a href="/dom/element.html" title="Element 节点">Element 节点</a></li><li><a href="/dom/attributes.html" title="属性的操作">属性的操作</a></li><li><a href="/dom/text.html" title="Text 节点和 DocumentFragment 节点">Text 节点和 DocumentFragment 节点</a></li><li><a href="/dom/mutationobserver.html" title="Mutation Observer API">Mutation Observer API</a></li></ul></li><li><a title="事件">事件<i class="fa fa-angle-down"></i></a><ul><li><a href="/events/eventtarget.html" title="EventTarget 接口">EventTarget 接口</a></li><li><a href="/events/model.html" title="事件模型">事件模型</a></li><li><a href="/events/event.html" title="Event 对象">Event 对象</a></li><li><a href="/events/mouse.html" title="鼠标事件">鼠标事件</a></li><li><a href="/events/keyboard.html" title="键盘事件">键盘事件</a></li><li><a href="/events/progress.html" title="进度事件">进度事件</a></li><li><a href="/events/form.html" title="表单事件">表单事件</a></li><li><a href="/events/touch.html" title="触摸事件">触摸事件</a></li><li><a href="/events/drag.html" title="拖拉事件">拖拉事件</a></li><li><a href="/events/common.html" title="其他常见事件">其他常见事件</a></li><li><a href="/events/globaleventhandlers.html" title="拖拉事件">拖拉事件</a></li></ul></li><li><a title="浏览器模型">浏览器模型<i class="fa fa-angle-down"></i></a><ul><li><a href="/bom/engine.html" title="浏览器环境概述">浏览器环境概述</a></li><li><a href="/bom/window.html" title="window 对象">window 对象</a></li><li><a href="/bom/navigator.html" title="Navigator 对象，Screen 对象">Navigator 对象，Screen 对象</a></li><li><a href="/bom/cookie.html" title="cookie">cookie</a></li><li><a href="/bom/xmlhttprequest.html" title="XMLHttpRequest 对象">XMLHttpRequest 对象</a></li><li><a href="/bom/same-origin.html" title="同源限制">同源限制</a></li><li><a href="/bom/cors.html" title="CORS 通信">CORS 通信</a></li><li><a href="/bom/storage.html" title="Storage 接口">Storage 接口</a></li><li><a href="/bom/history.html" title="History 对象">History 对象</a></li><li><a href="/bom/location.html" title="Location 对象，URL 对象，URLSearchParams 对象">Location 对象，URL 对象，URLSearchParams 对象</a></li><li><a href="/bom/arraybuffer.html" title="ArrayBuffer 对象，Blob 对象">ArrayBuffer 对象，Blob 对象</a></li><li><a href="/bom/file.html" title="File 对象，FileList 对象，FileReader 对象">File 对象，FileList 对象，FileReader 对象</a></li><li><a href="/bom/form.html" title="表单，FormData 对象">表单，FormData 对象</a></li><li><a href="/bom/indexeddb.html" title="IndexedDB API">IndexedDB API</a></li><li><a href="/bom/webworker.html" title="Web Worker">Web Worker</a></li></ul></li><li><a title="附录：网页元素接口">附录：网页元素接口<i class="fa fa-angle-down"></i></a><ul><li><a href="/elements/a.html" title="a 元素">a 元素</a></li><li><a href="/elements/image.html" title="img 元素">img 元素</a></li><li><a href="/elements/form.html" title="form 元素">form 元素</a></li><li><a href="/elements/input.html" title="input 元素">input 元素</a></li><li><a href="/elements/button.html" title="button 元素">button 元素</a></li><li><a href="/elements/option.html" title="option 元素">option 元素</a></li><li><a href="/elements/video.html" title="video，audio">video，audio</a></li></ul></li></ul></li></ul></body></html><div class="tea-version"><p>version: v0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>Object 对象的相关方法</span></h3></div><div class="tea-container"><div class="markdown-body"><h1><a href="#严格模式" class="header-anchor">#</a> <span>严格模式</span></h1><p>除了正常的运行模式，JavaScript 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JavaScript 语法。</p><p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。</p><h2><a href="#设计目的" class="header-anchor">#</a> <span>设计目的</span></h2><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p><p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p><ul><li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li><li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>为未来新版本的 JavaScript 语法做好铺垫。</li></ul><p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p><h2><a href="#启用方法" class="header-anchor">#</a> <span>启用方法</span></h2><p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;</code></pre><p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p><p>严格模式可以用于整个脚本，也可以只用于单个函数。</p><p><strong>（1） 整个脚本文件</strong></p><p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</p><pre class="prettyprint language-html"><code>&lt;script&gt;
  &#039;use strict&#039;;
  console.log(&#039;这是严格模式&#039;);
&lt;/script&gt;

&lt;script&gt;
  console.log(&#039;这是正常模式&#039;);
&lt;/script&gt;</code></pre><p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个<code>&lt;script&gt;</code>标签是严格模式，后一个不是。</p><p>如果<code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p><pre class="prettyprint language-html"><code>&lt;script&gt;
  console.log(&#039;这是正常模式&#039;);
  &#039;use strict&#039;;
&lt;/script&gt;</code></pre><p><strong>（2）单个函数</strong></p><p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p><pre class="prettyprint language-javascript"><code>function strict() {
  &#039;use strict&#039;;
  return &#039;这是严格模式&#039;;
}

function strict2() {
  &#039;use strict&#039;;
  function f() {
    return &#039;这也是严格模式&#039;;
  }
  return f();
}

function notStrict() {
  return &#039;这是正常模式&#039;;
}</code></pre><p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p><pre class="prettyprint language-javascript"><code>(function () {
  &#039;use strict&#039;;
  // some code here
})();</code></pre><h2><a href="#显式报错" class="header-anchor">#</a> <span>显式报错</span></h2><p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p><h3><a href="#只读属性不可写" class="header-anchor">#</a> <span>只读属性不可写</span></h3><p>严格模式下，设置字符串的<code>length</code>属性，会报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
&#039;abc&#039;.length = 5;
// TypeError: Cannot assign to read only property &#039;length&#039; of string &#039;abc&#039;</code></pre><p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错。</p><p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p><pre class="prettyprint language-javascript"><code>// 对只读属性赋值会报错
&#039;use strict&#039;;
Object.defineProperty({}, &#039;a&#039;, {
  value: 37,
  writable: false
});
obj.a = 123;
// TypeError: Cannot assign to read only property &#039;a&#039; of object #&lt;Object&gt;

// 删除不可配置的属性会报错
&#039;use strict&#039;;
var obj = Object.defineProperty({}, &#039;p&#039;, {
  value: 1,
  configurable: false
});
delete obj.p
// TypeError: Cannot delete property &#039;p&#039; of #&lt;Object&gt;</code></pre><h3><a href="#只设置了取值器的属性不可写" class="header-anchor">#</a> <span>只设置了取值器的属性不可写</span></h3><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var obj = {
  get v() { return 1; }
};
obj.v = 2;
// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</code></pre><p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错。</p><h3><a href="#禁止扩展的对象不可扩展" class="header-anchor">#</a> <span>禁止扩展的对象不可扩展</span></h3><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var obj = {};
Object.preventExtensions(obj);
obj.v = 1;
// Uncaught TypeError: Cannot add property v, object is not extensible</code></pre><p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错。</p><h3><a href="#eval、arguments-不可用作标识名" class="header-anchor">#</a> <span>eval、arguments 不可用作标识名</span></h3><p>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var eval = 17;
var arguments = 17;
var obj = { set p(arguments) { } };
try { } catch (arguments) { }
function x(eval) { }
function arguments() { }
var y = function eval() { };
var f = new Function(&#039;arguments&#039;, &quot;&#039;use strict&#039;; return 17;&quot;);
// SyntaxError: Unexpected eval or arguments in strict mode</code></pre><h3><a href="#函数不能有重名的参数" class="header-anchor">#</a> <span>函数不能有重名的参数</span></h3><p>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误。</p><pre class="prettyprint language-javascript"><code>function f(a, a, b) {
  &#039;use strict&#039;;
  return a + b;
}
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</code></pre><h3><a href="#禁止八进制的前缀0表示法" class="header-anchor">#</a> <span>禁止八进制的前缀0表示法</span></h3><p>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var n = 0100;
// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</code></pre><h2><a href="#增强的安全措施" class="header-anchor">#</a> <span>增强的安全措施</span></h2><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p><h3><a href="#全局变量显式声明" class="header-anchor">#</a> <span>全局变量显式声明</span></h3><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;

v = 1; // 报错，v未声明

for (i = 0; i &lt; 2; i++) { // 报错，i 未声明
  // ...
}

function f() {
  x = 123;
}
f() // 报错，未声明就创建一个全局变量</code></pre><p>因此，严格模式下，变量都必须先声明，然后再使用。</p><h3><a href="#禁止-this-关键字指向全局对象" class="header-anchor">#</a> <span>禁止 this 关键字指向全局对象</span></h3><p>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p><pre class="prettyprint language-javascript"><code>// 正常模式
function f() {
  console.log(this === window);
}
f() // true

// 严格模式
function f() {
  &#039;use strict&#039;;
  console.log(this === undefined);
}
f() // true</code></pre><p>上面代码中，严格模式的函数体内部<code>this</code>是<code>undefined</code>。</p><p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加<code>new</code>，这时<code>this</code>不再指向全局对象，而是报错。</p><pre class="prettyprint language-javascript"><code>function f() {
  &#039;use strict&#039;;
  this.a = 1;
};

f();// 报错，this 未定义</code></pre><p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略。</p><pre class="prettyprint language-javascript"><code>// 正常模式
function fun() {
  return this;
}

fun() // window
fun.call(2) // Number {2}
fun.call(true) // Boolean {true}
fun.call(null) // window
fun.call(undefined) // window

// 严格模式
&#039;use strict&#039;;
function fun() {
  return this;
}

fun() //undefined
fun.call(2) // 2
fun.call(true) // true
fun.call(null) // null
fun.call(undefined) // undefined</code></pre><p>上面代码中，可以把任意类型的值，绑定在<code>this</code>上面。</p><h3><a href="#禁止使用-fn.callee、fn.caller" class="header-anchor">#</a> <span>禁止使用 fn.callee、fn.caller</span></h3><p>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p><pre class="prettyprint language-javascript"><code>function f1() {
  &#039;use strict&#039;;
  f1.caller;    // 报错
  f1.arguments; // 报错
}

f1();</code></pre><h3><a href="#禁止使用-arguments.callee、arguments.caller" class="header-anchor">#</a> <span>禁止使用 arguments.callee、arguments.caller</span></h3><p><code>arguments.callee</code>和<code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用<code>arguments.callee</code>、<code>arguments.caller</code>将会报错。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var f = function () {
  return arguments.callee;
};

f(); // 报错</code></pre><h3><a href="#禁止删除变量" class="header-anchor">#</a> <span>禁止删除变量</span></h3><p>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var x;
delete x; // 语法错误

var obj = Object.create(null, {
  x: {
    value: 1,
    configurable: true
  }
});
delete obj.x; // 删除成功</code></pre><h2><a href="#静态绑定" class="header-anchor">#</a> <span>静态绑定</span></h2><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p><p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p><p>具体来说，涉及以下几个方面。</p><h3><a href="#禁止使用-with-语句" class="header-anchor">#</a> <span>禁止使用 with 语句</span></h3><p>严格模式下，使用<code>with</code>语句将报错。因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
var v  = 1;
var obj = {};

with (obj) {
  v = 2;
}
// Uncaught SyntaxError: Strict mode code may not include a with statement</code></pre><h3><a href="#创设-eval-作用域" class="header-anchor">#</a> <span>创设 eval 作用域</span></h3><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</p><p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部。</p><pre class="prettyprint language-javascript"><code>(function () {
  &#039;use strict&#039;;
  var x = 2;
  console.log(eval(&#039;var x = 5; x&#039;)) // 5
  console.log(x) // 2
})()</code></pre><p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部。</p><p>注意，如果希望<code>eval</code>语句也使用严格模式，有两种方式。</p><pre class="prettyprint language-javascript"><code>// 方式一
function f1(str){
  &#039;use strict&#039;;
  return eval(str);
}
f1(&#039;undeclared_variable = 1&#039;); // 报错

// 方式二
function f2(str){
  return eval(str);
}
f2(&#039;&quot;use strict&quot;;undeclared_variable = 1&#039;)  // 报错</code></pre><p>上面两种写法，<code>eval</code>内部使用的都是严格模式。</p><h3><a href="#arguments-不再追踪参数的变化" class="header-anchor">#</a> <span>arguments 不再追踪参数的变化</span></h3><p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p><pre class="prettyprint language-javascript"><code>function f(a) {
  a = 2;
  return [a, arguments[0]];
}
f(1); // 正常模式为[2, 2]

function f(a) {
  &#039;use strict&#039;;
  a = 2;
  return [a, arguments[0]];
}
f(1); // 严格模式为[2, 1]</code></pre><p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p><h2><a href="#向下一个版本的-JavaScript-过渡" class="header-anchor">#</a> <span>向下一个版本的 JavaScript 过渡</span></h2><p>JavaScript语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p><h3><a href="#非函数代码块不得声明函数" class="header-anchor">#</a> <span>非函数代码块不得声明函数</span></h3><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p><pre class="prettyprint language-javascript"><code>&#039;use strict&#039;;
if (true) {
  function f1() { } // 语法错误
}

for (var i = 0; i &lt; 5; i++) {
  function f2() { } // 语法错误
}</code></pre><p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错。</p><p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。</p><h3><a href="#保留字" class="header-anchor">#</a> <span>保留字</span></h3><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p><pre class="prettyprint language-javascript"><code>function package(protected) { // 语法错误
  &#039;use strict&#039;;
  var implements; // 语法错误
}</code></pre><h2><a href="#参考链接" class="header-anchor">#</a> <span>参考链接</span></h2><ul><li>MDN, <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict mode</a></li><li>Dr. Axel Rauschmayer, <a href="http://www.2ality.com/2011/10/strict-mode-hatred.html">JavaScript: Why the hatred for strict mode?</a></li><li>Dr. Axel Rauschmayer，<a href="http://www.2ality.com/2011/01/javascripts-strict-mode-summary.html">JavaScript’s strict mode: a summary</a></li><li>Douglas Crockford, <a href="http://www.yuiblog.com/blog/2010/12/14/strict-mode-is-coming-to-town/">Strict Mode Is Coming To Town</a></li><li><a href="http://java-script.limewebs.com/strictMode/test_hosted.html">JavaScript Strict Mode Support</a></li></ul></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script></body></html>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
