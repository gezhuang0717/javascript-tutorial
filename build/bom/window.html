<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content="欢迎使用Teadocs文档生成系统"><meta name="keywords" content="teadocs, 文档生成器"><title>window 对象 - 阮一峰的JavaScript教程</title><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script src="https://cdn.bootcss.com/socket.io/2.1.1/socket.io.js"></script><script>window._CONST={THEME_DIR:"{{_CONST.THEME_DIR}}"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>阮一峰的JavaScript教程</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value="" height="100%"></div><html><head></head><body><ul class="tea-menu-list"><li><a href="/index.html" title="关于" class="">关于</a></li><li><a href="/preface.html" title="阮一峰前言" class="">阮一峰前言</a></li><li><a title="教程" class="active">教程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="入门篇" class="">入门篇<i class="fa fa-angle-down"></i></a><ul><li><a href="/basic/introduction.html" title="导论" class="">导论</a></li><li><a href="/basic/history.html" title="历史" class="">历史</a></li><li><a href="/basic/grammar.html" title="基本语法" class="">基本语法</a></li></ul></li><li><a title="数据类型" class="">数据类型<i class="fa fa-angle-down"></i></a><ul><li><a href="/types/general.html" title="概述" class="">概述</a></li><li><a href="/types/null-undefined-boolean.html" title="null，undefined和布尔值" class="">null，undefined和布尔值</a></li><li><a href="/types/number.html" title="数值" class="">数值</a></li><li><a href="/types/string.html" title="字符串" class="">字符串</a></li><li><a href="/types/object.html" title="对象" class="">对象</a></li><li><a href="/types/function.html" title="函数" class="">函数</a></li><li><a href="/types/array.html" title="数组" class="">数组</a></li></ul></li><li><a title="运算符" class="">运算符<i class="fa fa-angle-down"></i></a><ul><li><a href="/operators/arithmetic.html" title="算术运算符" class="">算术运算符</a></li><li><a href="/operators/comparison.html" title="比较运算符" class="">比较运算符</a></li><li><a href="/operators/boolean.html" title="布尔运算符" class="">布尔运算符</a></li><li><a href="/operators/bit.html" title="二进制位运算符" class="">二进制位运算符</a></li><li><a href="/operators/priority.html" title="其他运算符，运算顺序" class="">其他运算符，运算顺序</a></li></ul></li><li><a title="语法专题" class="">语法专题<i class="fa fa-angle-down"></i></a><ul><li><a href="/features/conversion.html" title="数据类型的转换" class="">数据类型的转换</a></li><li><a href="/features/error.html" title="错误处理机制" class="">错误处理机制</a></li><li><a href="/features/style.html" title="编程风格" class="">编程风格</a></li><li><a href="/features/console.html" title="console 对象与控制台" class="">console 对象与控制台</a></li></ul></li><li><a title="标准库" class="">标准库<i class="fa fa-angle-down"></i></a><ul><li><a href="/stdlib/object.html" title="Object对象" class="">Object对象</a></li><li><a href="/stdlib/attributes.html" title="属性描述对象" class="">属性描述对象</a></li><li><a href="/stdlib/array.html" title="Array 对象" class="">Array 对象</a></li><li><a href="/stdlib/wrapper.html" title="包装对象" class="">包装对象</a></li><li><a href="/stdlib/boolean.html" title="Boolean 对象" class="">Boolean 对象</a></li><li><a href="/stdlib/number.html" title="Number 对象" class="">Number 对象</a></li><li><a href="/stdlib/string.html" title="String 对象" class="">String 对象</a></li><li><a href="/stdlib/math.html" title="Math 对象" class="">Math 对象</a></li><li><a href="/stdlib/date.html" title="Date 对象" class="">Date 对象</a></li><li><a href="/stdlib/regexp.html" title="RegExp 对象" class="">RegExp 对象</a></li><li><a href="/stdlib/json.html" title="JSON 对象" class="">JSON 对象</a></li></ul></li><li><a title="面向对象编程" class="">面向对象编程<i class="fa fa-angle-down"></i></a><ul><li><a href="/oop/new.html" title="实例对象与 new 命令" class="">实例对象与 new 命令</a></li><li><a href="/oop/this.html" title="this 关键字" class="">this 关键字</a></li><li><a href="/oop/prototype.html" title="对象的继承" class="">对象的继承</a></li><li><a href="/oop/object.html" title="Object 对象的相关方法" class="">Object 对象的相关方法</a></li><li><a href="/oop/strict.html" title="Object 对象的相关方法" class="">Object 对象的相关方法</a></li></ul></li><li><a title="异步操作" class="">异步操作<i class="fa fa-angle-down"></i></a><ul><li><a href="/async/general.html" title="概述" class="">概述</a></li><li><a href="/async/timer.html" title="定时器" class="">定时器</a></li><li><a href="/async/promise.html" title="Promise 对象" class="">Promise 对象</a></li></ul></li><li><a title="DOM" class="">DOM<i class="fa fa-angle-down"></i></a><ul><li><a href="/dom/general.html" title="概述" class="">概述</a></li><li><a href="/dom/node.html" title="Node 接口" class="">Node 接口</a></li><li><a href="/dom/nodelist.html" title="NodeList 接口，HTMLCollection 接口" class="">NodeList 接口，HTMLCollection 接口</a></li><li><a href="/dom/parentnode.html" title="ParentNode 接口，ChildNode 接口" class="">ParentNode 接口，ChildNode 接口</a></li><li><a href="/dom/document.html" title="Document 节点" class="">Document 节点</a></li><li><a href="/dom/element.html" title="Element 节点" class="">Element 节点</a></li><li><a href="/dom/attributes.html" title="属性的操作" class="">属性的操作</a></li><li><a href="/dom/text.html" title="Text 节点和 DocumentFragment 节点" class="">Text 节点和 DocumentFragment 节点</a></li><li><a href="/dom/mutationobserver.html" title="Mutation Observer API" class="">Mutation Observer API</a></li></ul></li><li><a title="事件" class="">事件<i class="fa fa-angle-down"></i></a><ul><li><a href="/events/eventtarget.html" title="EventTarget 接口" class="">EventTarget 接口</a></li><li><a href="/events/model.html" title="事件模型" class="">事件模型</a></li><li><a href="/events/event.html" title="Event 对象" class="">Event 对象</a></li><li><a href="/events/mouse.html" title="鼠标事件" class="">鼠标事件</a></li><li><a href="/events/keyboard.html" title="键盘事件" class="">键盘事件</a></li><li><a href="/events/progress.html" title="进度事件" class="">进度事件</a></li><li><a href="/events/form.html" title="表单事件" class="">表单事件</a></li><li><a href="/events/touch.html" title="触摸事件" class="">触摸事件</a></li><li><a href="/events/drag.html" title="拖拉事件" class="">拖拉事件</a></li><li><a href="/events/common.html" title="其他常见事件" class="">其他常见事件</a></li><li><a href="/events/globaleventhandlers.html" title="拖拉事件" class="">拖拉事件</a></li></ul></li><li><a title="浏览器模型" class="active">浏览器模型<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/bom/engine.html" title="浏览器环境概述" class="">浏览器环境概述</a></li><li><a href="/bom/window.html" title="window 对象" class="active">window 对象</a></li><li><a href="/bom/navigator.html" title="Navigator 对象，Screen 对象">Navigator 对象，Screen 对象</a></li><li><a href="/bom/cookie.html" title="cookie">cookie</a></li><li><a href="/bom/xmlhttprequest.html" title="XMLHttpRequest 对象">XMLHttpRequest 对象</a></li><li><a href="/bom/same-origin.html" title="同源限制">同源限制</a></li><li><a href="/bom/cors.html" title="CORS 通信">CORS 通信</a></li><li><a href="/bom/storage.html" title="Storage 接口">Storage 接口</a></li><li><a href="/bom/history.html" title="History 对象">History 对象</a></li><li><a href="/bom/location.html" title="Location 对象，URL 对象，URLSearchParams 对象">Location 对象，URL 对象，URLSearchParams 对象</a></li><li><a href="/bom/arraybuffer.html" title="ArrayBuffer 对象，Blob 对象">ArrayBuffer 对象，Blob 对象</a></li><li><a href="/bom/file.html" title="File 对象，FileList 对象，FileReader 对象">File 对象，FileList 对象，FileReader 对象</a></li><li><a href="/bom/form.html" title="表单，FormData 对象">表单，FormData 对象</a></li><li><a href="/bom/indexeddb.html" title="IndexedDB API">IndexedDB API</a></li><li><a href="/bom/webworker.html" title="Web Worker">Web Worker</a></li></ul></li><li><a title="附录：网页元素接口">附录：网页元素接口<i class="fa fa-angle-down"></i></a><ul><li><a href="/elements/a.html" title="a 元素">a 元素</a></li><li><a href="/elements/image.html" title="img 元素">img 元素</a></li><li><a href="/elements/form.html" title="form 元素">form 元素</a></li><li><a href="/elements/input.html" title="input 元素">input 元素</a></li><li><a href="/elements/button.html" title="button 元素">button 元素</a></li><li><a href="/elements/option.html" title="option 元素">option 元素</a></li><li><a href="/elements/video.html" title="video，audio">video，audio</a></li></ul></li></ul></li></ul></body></html><div class="tea-version"><p>version: v0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>window 对象</span></h3></div><div class="tea-container"><div class="markdown-body"><h1><a href="#window-对象" class="header-anchor">#</a> <span>window 对象</span></h1><h2><a href="#概述" class="header-anchor">#</a> <span>概述</span></h2><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p><pre class="prettyprint language-javascript"><code>a = 1;
window.a // 1</code></pre><p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p><p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p><h2><a href="#window-对象的属性" class="header-anchor">#</a> <span>window 对象的属性</span></h2><h3><a href="#window.name" class="header-anchor">#</a> <span>window.name</span></h3><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p><pre class="prettyprint language-javascript"><code>window.name = &#039;Hello World!&#039;;
console.log(window.name)
// &quot;Hello World!&quot;</code></pre><p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p><p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这是窗口已经不存在了。</p><h3><a href="#window.closed，window.opener" class="header-anchor">#</a> <span>window.closed，window.opener</span></h3><p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p><pre class="prettyprint language-javascript"><code>window.closed // false</code></pre><p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p><pre class="prettyprint language-javascript"><code>var popup = window.open();

if ((popup !== null) &amp;&amp; !popup.closed) {
  // 窗口仍然打开着
}</code></pre><p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>window.open().opener === window // true</code></pre><p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p><p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口。</p><h3><a href="#window.self，window.window" class="header-anchor">#</a> <span>window.self，window.window</span></h3><p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p><pre class="prettyprint language-javascript"><code>window.self === window // true
window.window === window // true</code></pre><h3><a href="#window.frames，window.length" class="header-anchor">#</a> <span>window.frames，window.length</span></h3><p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p><p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=&quot;myIFrame&quot;&gt;</code>可以用<code>frames[&#39;myIFrame&#39;]</code>或者<code>frames.myIFrame</code>来引用。</p><p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p><pre class="prettyprint language-javascript"><code>frames === window // true</code></pre><p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p><p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p><pre class="prettyprint language-javascript"><code>window.frames.length === window.length // true</code></pre><p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p><h3><a href="#window.frameElement" class="header-anchor">#</a> <span>window.frameElement</span></h3><p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>或<code>&lt;embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;iframe src=&quot;about.html&quot;&gt;&lt;/iframe&gt;

// 下面的脚本在 about.html 里面
var frameEl = window.frameElement;
if (frameEl) {
  frameEl.src = &#039;other.html&#039;;
}</code></pre><p>上面代码中，<code>frameEl</code>变量就是<code>&lt;iframe&gt;</code>元素。</p><h3><a href="#window.top，window.parent" class="header-anchor">#</a> <span>window.top，window.parent</span></h3><p><code>window.top</code>属性指向最顶层窗口，主要用于在子窗口里面获取顶层的父窗口。</p><p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p><pre class="prettyprint language-javascript"><code>if (window.parent !== window.top) {
  // 表明当前窗口嵌入不止一层
}</code></pre><h3><a href="#window.status" class="header-anchor">#</a> <span>window.status</span></h3><p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p><h3><a href="#window.devicePixelRatio" class="header-anchor">#</a> <span>window.devicePixelRatio</span></h3><p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p><h3><a href="#位置大小属性" class="header-anchor">#</a> <span>位置大小属性</span></h3><p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p><p><strong>（1）window.screenX，window.screenY</strong></p><p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p><p><strong>（2） window.innerHeight，window.innerWidth</strong></p><p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p><p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因为可见部分（视口）就变小了。</p><p>注意，这两个属性值包括滚动条的高度和宽度。</p><p><strong>（3）window.outerHeight，window.outerWidth</strong></p><p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p><p><strong>（4）window.scrollX，window.scrollY</strong></p><p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p><p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p><p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p><pre class="prettyprint language-javascript"><code>if (window.scrollY &lt; 75) {
  window.scroll(0, 75);
}</code></pre><p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p><p><strong>（5）window.pageXOffset，window.pageYOffset</strong></p><p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p><h3><a href="#组件属性" class="header-anchor">#</a> <span>组件属性</span></h3><p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p><ul><li><code>window.locationbar</code>：地址栏对象</li><li><code>window.menubar</code>：菜单栏对象</li><li><code>window.scrollbars</code>：窗口的滚动条对象</li><li><code>window.toolbar</code>：工具栏对象</li><li><code>window.statusbar</code>：状态栏对象</li><li><code>window.personalbar</code>：用户安装的个人工具栏对象</li></ul><p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p><pre class="prettyprint language-javascript"><code>window.locationbar.visible
window.menubar.visible
window.scrollbars.visible
window.toolbar.visible
window.statusbar.visible
window.personalbar.visible</code></pre><h3><a href="#全局对象属性" class="header-anchor">#</a> <span>全局对象属性</span></h3><p>全局对象属性指向一些浏览器原生的全局对象。</p><ul><li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li><li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。</li><li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息，详见《Navigator 对象》一章。</li><li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史，详见《History 对象》一章。</li><li><code>window.localStorage</code>：指向本地储存的 localStorage 数据，详见《Storage 接口》一章。</li><li><code>window.sessionStorage</code>：指向本地储存的 sessionStorage 数据，详见《Storage 接口》一章。</li><li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台，详见《console 对象》一章。</li><li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息，详见《Screen 对象》一章。</li></ul><h3><a href="#window.isSecureContext" class="header-anchor">#</a> <span>window.isSecureContext</span></h3><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p><h2><a href="#window-对象的方法" class="header-anchor">#</a> <span>window 对象的方法</span></h2><h3><a href="#window.alert()，window.prompt()，window.confirm()" class="header-anchor">#</a> <span>window.alert()，window.prompt()，window.confirm()</span></h3><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p><p><strong>（1）window.alert()</strong></p><p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p><pre class="prettyprint language-javascript"><code>window.alert(&#039;Hello World&#039;);</code></pre><p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p><p><code>window.alert()</code>方法的参数只能是字符串，没法使用CSS样式，但是可以用<code>\n</code>指定换行。</p><pre class="prettyprint language-javascript"><code>alert(&#039;本条提示\n分成两行&#039;);</code></pre><p><strong>（2）window.prompt()</strong></p><p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p><pre class="prettyprint language-javascript"><code>var result = prompt(&#039;您的年龄？&#039;, 25)</code></pre><p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p><p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p><ol><li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li><li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li><li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li></ol><p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p><p><strong>（3）window.confirm()</strong></p><p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p><pre class="prettyprint language-javascript"><code>var result = confirm(&#039;你最近好吗？&#039;);</code></pre><p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p><p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p><pre class="prettyprint language-javascript"><code>var okay = confirm(&#039;Please confirm this message.&#039;);
if (okay) {
  // 用户按下“确定”
} else {
  // 用户按下“取消”
}</code></pre><p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p><pre class="prettyprint language-javascript"><code>window.onunload = function () {
  return window.confirm(&#039;你确定要离开当面页面吗？&#039;);
}</code></pre><p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p><h3><a href="#window.open(),-window.close()，window.stop()" class="header-anchor">#</a> <span>window.open(), window.close()，window.stop()</span></h3><p><strong>（1）window.open()</strong></p><p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>var popup = window.open(&#039;somefile.html&#039;);</code></pre><p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p><p><code>open</code>方法一共可以接受三个参数。</p><pre class="prettyprint language-javascript"><code>window.open(url, windowName, [windowFeatures])</code></pre><ul><li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li><li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。</li><li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li></ul><p>下面是一个例子。</p><pre class="prettyprint language-javascript"><code>var popup = window.open(
  &#039;somepage.html&#039;,
  &#039;DefinitionsWindows&#039;,
  &#039;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#039;
);</code></pre><p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏和滚动条，但有状态栏，允许用户调整大小。</p><p>第三个参数可以设定如下属性。</p><ul><li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li><li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li><li>height：新窗口内容区域的高度（单位像素），不得小于100。</li><li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li><li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li><li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li><li>menubar：是否显示菜单栏。</li><li>toolbar：是否显示工具栏。</li><li>location：是否显示地址栏。</li><li>personalbar：是否显示用户自己安装的工具栏。</li><li>status：是否显示状态栏。</li><li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li><li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li><li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li><li>resizable：新窗口是否可以调节大小。</li><li>scrollbars：是否允许新窗口出现滚动条。</li><li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li><li>titlebar：新窗口是否显示标题栏。</li><li>alwaysRaised：是否显示在所有窗口的顶部。</li><li>alwaysLowered：是否显示在父窗口的底下。</li><li>close：新窗口是否显示关闭按钮。</li></ul><p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p><p>另外，<code>open</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p><p><code>window.open</code>方法返回新窗口的引用。</p><pre class="prettyprint language-javascript"><code>var windowB = window.open(&#039;windowB.html&#039;, &#039;WindowB&#039;);
windowB.window.name // &quot;WindowB&quot;</code></pre><p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能窗口对象获取对方的内部属性。</p><p>下面是另一个例子。</p><pre class="prettyprint language-javascript"><code>var w = window.open();
console.log(&#039;已经打开新窗口&#039;);
w.location = &#039;http://example.com&#039;;</code></pre><p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p><p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p><pre class="prettyprint language-javascript"><code>var popup = window.open();
if (popup === null) {
  // 新建窗口失败
}</code></pre><p><strong>（2）window.close()</strong></p><p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p><pre class="prettyprint language-javascript"><code>popup.close()</code></pre><p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p><p><strong>（3）window.stop()</strong></p><p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p><pre class="prettyprint language-javascript"><code>window.stop()</code></pre><h3><a href="#window.moveTo()，window.moveBy()" class="header-anchor">#</a> <span>window.moveTo()，window.moveBy()</span></h3><p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p><pre class="prettyprint language-javascript"><code>window.moveTo(100, 200)</code></pre><p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p><p><code>window.moveBy</code>方法将窗口移动到一个相对位置。它接受两个参数，分布是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p><pre class="prettyprint language-javascript"><code>window.moveBy(25, 50)</code></pre><p>上面代码将窗口向右移动25像素、向下移动50像素。</p><p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open</code>方法新建的，并且它所在的 Tab 页是当前窗口里面唯一的。除此以外的情况，使用上面两个方法都是无效的。</p><h3><a href="#window.resizeTo()，window.resizeBy()" class="header-anchor">#</a> <span>window.resizeTo()，window.resizeBy()</span></h3><p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p><p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p><pre class="prettyprint language-javascript"><code>window.resizeTo(
  window.screen.availWidth / 2,
  window.screen.availHeight / 2
)</code></pre><p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p><p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p><p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p><pre class="prettyprint language-javascript"><code>window.resizeBy(-200, -200)</code></pre><p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p><h3><a href="#window.scrollTo()，window.scroll()，window.scrollBy()" class="header-anchor">#</a> <span>window.scrollTo()，window.scroll()，window.scrollBy()</span></h3><p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p><pre class="prettyprint language-javascript"><code>window.scrollTo(x-coord, y-coord)</code></pre><p>它也可以接受一个配置对象作为参数。</p><pre class="prettyprint language-javascript"><code>window.scrollTo(options)</code></pre><p>配置对象<code>options</code>有三个属性。</p><ul><li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li><li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li><li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li></ul><pre class="prettyprint language-javascript"><code>window.scrollTo({
  top: 1000,
  behavior: &#039;smooth&#039;
});</code></pre><p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p><p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p><pre class="prettyprint language-javascript"><code>window.scrollBy(0, window.innerHeight)</code></pre><p>上面代码用于将网页向下滚动一屏。</p><p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p><ul><li>Element.scrollTop</li><li>Element.scrollLeft</li><li>Element.scrollIntoView()</li></ul><h3><a href="#window.print()" class="header-anchor">#</a> <span>window.print()</span></h3><p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p><p>常见的打印按钮代码如下。</p><pre class="prettyprint language-javascript"><code>document.getElementById(&#039;printLink&#039;).onclick = function () {
  window.print();
}</code></pre><p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p><pre class="prettyprint language-javascript"><code>if (typeof window.print === &#039;function&#039;) {
  // 支持打印功能
}</code></pre><h3><a href="#window.focus()，window.blur()" class="header-anchor">#</a> <span>window.focus()，window.blur()</span></h3><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p><pre class="prettyprint language-javascript"><code>var popup = window.open(&#039;popup.html&#039;, &#039;Popup Window&#039;);

if ((popup !== null) &amp;&amp; !popup.closed) {
  popup.focus();
}</code></pre><p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p><p><code>window.blur()</code>方法将焦点从窗口移除。</p><p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p><h3><a href="#window.getSelection()" class="header-anchor">#</a> <span>window.getSelection()</span></h3><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p><pre class="prettyprint language-javascript"><code>var selObj = window.getSelection();</code></pre><p>使用<code>Selction</code>对象的<code>toString</code>方法可以得到选中的文本。</p><pre class="prettyprint language-javascript"><code>var selectedText = selObj.toString();</code></pre><h3><a href="#window.getComputedStyle()，window.matchMedia()" class="header-anchor">#</a> <span>window.getComputedStyle()，window.matchMedia()</span></h3><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象，详见《CSS 操作》一章。</p><p><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句，详见《CSS 操作》一章。</p><h2><a href="#事件" class="header-anchor">#</a> <span>事件</span></h2><p><code>window</code>对象可以接收以下事件。</p><h3><a href="#load-事件和-onload-属性" class="header-anchor">#</a> <span>load 事件和 onload 属性</span></h3><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p><pre class="prettyprint language-javascript"><code>window.onload = function() {
  var elements = document.getElementsByClassName(&#039;example&#039;);
  for (var i = 0; i &lt; elements.length; i++) {
    var elt = elements[i];
    // ...
  }
};</code></pre><p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p><h3><a href="#error-事件和-onerror-属性" class="header-anchor">#</a> <span>error 事件和 onerror 属性</span></h3><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p><pre class="prettyprint language-javascript"><code>window.onerror = function (message, filename, lineno, colno, error) {
  console.log(&quot;出错了！--&gt; %s&quot;, error.stack);
};</code></pre><p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p><ul><li>出错信息</li><li>出错脚本的网址</li><li>行号</li><li>列号</li><li>错误对象</li></ul><p>老式浏览器只支持前三个参数。</p><p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p><p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p><pre class="prettyprint language-javascript"><code>window.onerror = function(msg, url, line) {
  if (onerror.num++ &gt; onerror.max) {
    alert(&#039;ERROR: &#039; + msg + &#039;\n&#039; + url + &#039;:&#039; + line);
    return true;
  }
}
onerror.max = 3;
onerror.num = 0;</code></pre><p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p><pre class="prettyprint language-bash"><code>Access-Control-Allow-Origin: *</code></pre><p>然后，在网页的<code>&lt;script&gt;</code>标签中设置<code>crossorigin</code>属性。</p><pre class="prettyprint language-html"><code>&lt;script crossorigin=&quot;anonymous&quot; src=&quot;//example.com/file.js&quot;&gt;&lt;/script&gt;</code></pre><p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p><h3><a href="#window-对象的事件监听属性" class="header-anchor">#</a> <span>window 对象的事件监听属性</span></h3><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p><ul><li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li><li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li><li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li><li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li><li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li><li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li><li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li><li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li><li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li><li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li><li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li><li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li><li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li><li><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。</li><li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li></ul><h2><a href="#多窗口操作" class="header-anchor">#</a> <span>多窗口操作</span></h2><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p><h3><a href="#窗口的引用" class="header-anchor">#</a> <span>窗口的引用</span></h3><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p><ul><li><code>top</code>：顶层窗口，即最上层的那个窗口</li><li><code>parent</code>：父窗口</li><li><code>self</code>：当前窗口，即自身</li></ul><p>下面代码可以判断，当前窗口是否为顶层窗口。</p><pre class="prettyprint language-javascript"><code>if (window.top === window.self) {
  // 当前窗口是顶层窗口
} else {
  // 当前窗口是子窗口
}</code></pre><p>下面的代码让父窗口的访问历史后退一次。</p><pre class="prettyprint language-javascript"><code>window.parent.history.back();</code></pre><p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt;a&gt;</code>标签、<code>&lt;form&gt;</code>标签等引用。</p><ul><li><code>_top</code>：顶层窗口</li><li><code>_parent</code>：父窗口</li><li><code>_blank</code>：新窗口</li></ul><p>下面代码就表示在顶层窗口打开链接。</p><pre class="prettyprint language-html"><code>&lt;a href=&quot;somepage.html&quot; target=&quot;_top&quot;&gt;Link&lt;/a&gt;</code></pre><h3><a href="#iframe-元素" class="header-anchor">#</a> <span>iframe 元素</span></h3><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p><pre class="prettyprint language-javascript"><code>var frame = document.getElementById(&#039;theFrame&#039;);
var frameWindow = frame.contentWindow;</code></pre><p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p><pre class="prettyprint language-javascript"><code>// 获取子窗口的标题
frameWindow.title</code></pre><p><code>&lt;iframe&gt;</code>元素的<code>contentDocument</code>属性，可以拿到子窗口的<code>document</code>对象。</p><pre class="prettyprint language-javascript"><code>var frame = document.getElementById(&#039;theFrame&#039;);
var frameDoc = frame.contentDocument;

// 等同于
var frameDoc = frame.contentWindow.document;</code></pre><p><code>&lt;iframe&gt;</code>元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用<code>window.postMessage</code>方法。</p><p><code>&lt;iframe&gt;</code>窗口内部，使用<code>window.parent</code>引用父窗口。如果当前页面没有父窗口，则<code>window.parent</code>属性返回自身。因此，可以通过<code>window.parent</code>是否等于<code>window.self</code>，判断当前窗口是否为<code>iframe</code>窗口。</p><pre class="prettyprint language-javascript"><code>if (window.parent !== window.self) {
  // 当前窗口是子窗口
}</code></pre><p><code>&lt;iframe&gt;</code>窗口的<code>window</code>对象，有一个<code>frameElement</code>属性，返回<code>&lt;iframe&gt;</code>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于<code>null</code>。</p><pre class="prettyprint language-javascript"><code>var f1Element = document.getElementById(&#039;f1&#039;);
var f1Window = f1Element.contentWindow;

f1Window.frameElement === f1Element // true
window.frameElement === null // true</code></pre><h3><a href="#window.frames-属性" class="header-anchor">#</a> <span>window.frames 属性</span></h3><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p><p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p><p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p><pre class="prettyprint language-javascript"><code>// HTML 代码为 &lt;iframe id=&quot;myFrame&quot;&gt;
window.myFrame // [HTMLIFrameElement]
frames.myframe === myFrame // true</code></pre><p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script></body></html>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
