<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content="欢迎使用Teadocs文档生成系统"><meta name="keywords" content="teadocs, 文档生成器"><title>Node 接口 - 阮一峰的JavaScript教程</title><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script src="https://cdn.bootcss.com/socket.io/2.1.1/socket.io.js"></script><script>window._CONST={THEME_DIR:"{{_CONST.THEME_DIR}}"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>阮一峰的JavaScript教程</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value="" height="100%"></div><html><head></head><body><ul class="tea-menu-list"><li><a href="/index.html" title="关于" class="">关于</a></li><li><a href="/preface.html" title="阮一峰前言" class="">阮一峰前言</a></li><li><a title="教程" class="active">教程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="入门篇" class="">入门篇<i class="fa fa-angle-down"></i></a><ul><li><a href="/basic/introduction.html" title="导论" class="">导论</a></li><li><a href="/basic/history.html" title="历史" class="">历史</a></li><li><a href="/basic/grammar.html" title="基本语法" class="">基本语法</a></li></ul></li><li><a title="数据类型" class="">数据类型<i class="fa fa-angle-down"></i></a><ul><li><a href="/types/general.html" title="概述" class="">概述</a></li><li><a href="/types/null-undefined-boolean.html" title="null，undefined和布尔值" class="">null，undefined和布尔值</a></li><li><a href="/types/number.html" title="数值" class="">数值</a></li><li><a href="/types/string.html" title="字符串" class="">字符串</a></li><li><a href="/types/object.html" title="对象" class="">对象</a></li><li><a href="/types/function.html" title="函数" class="">函数</a></li><li><a href="/types/array.html" title="数组" class="">数组</a></li></ul></li><li><a title="运算符" class="">运算符<i class="fa fa-angle-down"></i></a><ul><li><a href="/operators/arithmetic.html" title="算术运算符" class="">算术运算符</a></li><li><a href="/operators/comparison.html" title="比较运算符" class="">比较运算符</a></li><li><a href="/operators/boolean.html" title="布尔运算符" class="">布尔运算符</a></li><li><a href="/operators/bit.html" title="二进制位运算符" class="">二进制位运算符</a></li><li><a href="/operators/priority.html" title="其他运算符，运算顺序" class="">其他运算符，运算顺序</a></li></ul></li><li><a title="语法专题" class="">语法专题<i class="fa fa-angle-down"></i></a><ul><li><a href="/features/conversion.html" title="数据类型的转换" class="">数据类型的转换</a></li><li><a href="/features/error.html" title="错误处理机制" class="">错误处理机制</a></li><li><a href="/features/style.html" title="编程风格" class="">编程风格</a></li><li><a href="/features/console.html" title="console 对象与控制台" class="">console 对象与控制台</a></li></ul></li><li><a title="标准库" class="">标准库<i class="fa fa-angle-down"></i></a><ul><li><a href="/stdlib/object.html" title="Object对象" class="">Object对象</a></li><li><a href="/stdlib/attributes.html" title="属性描述对象" class="">属性描述对象</a></li><li><a href="/stdlib/array.html" title="Array 对象" class="">Array 对象</a></li><li><a href="/stdlib/wrapper.html" title="包装对象" class="">包装对象</a></li><li><a href="/stdlib/boolean.html" title="Boolean 对象" class="">Boolean 对象</a></li><li><a href="/stdlib/number.html" title="Number 对象" class="">Number 对象</a></li><li><a href="/stdlib/string.html" title="String 对象" class="">String 对象</a></li><li><a href="/stdlib/math.html" title="Math 对象" class="">Math 对象</a></li><li><a href="/stdlib/date.html" title="Date 对象" class="">Date 对象</a></li><li><a href="/stdlib/regexp.html" title="RegExp 对象" class="">RegExp 对象</a></li><li><a href="/stdlib/json.html" title="JSON 对象" class="">JSON 对象</a></li></ul></li><li><a title="面向对象编程" class="">面向对象编程<i class="fa fa-angle-down"></i></a><ul><li><a href="/oop/new.html" title="实例对象与 new 命令" class="">实例对象与 new 命令</a></li><li><a href="/oop/this.html" title="this 关键字" class="">this 关键字</a></li><li><a href="/oop/prototype.html" title="对象的继承" class="">对象的继承</a></li><li><a href="/oop/object.html" title="Object 对象的相关方法" class="">Object 对象的相关方法</a></li><li><a href="/oop/strict.html" title="Object 对象的相关方法" class="">Object 对象的相关方法</a></li></ul></li><li><a title="异步操作" class="">异步操作<i class="fa fa-angle-down"></i></a><ul><li><a href="/async/general.html" title="概述" class="">概述</a></li><li><a href="/async/timer.html" title="定时器" class="">定时器</a></li><li><a href="/async/promise.html" title="Promise 对象" class="">Promise 对象</a></li></ul></li><li><a title="DOM" class="active">DOM<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/dom/general.html" title="概述" class="">概述</a></li><li><a href="/dom/node.html" title="Node 接口" class="active">Node 接口</a></li><li><a href="/dom/nodelist.html" title="NodeList 接口，HTMLCollection 接口">NodeList 接口，HTMLCollection 接口</a></li><li><a href="/dom/parentnode.html" title="ParentNode 接口，ChildNode 接口">ParentNode 接口，ChildNode 接口</a></li><li><a href="/dom/document.html" title="Document 节点">Document 节点</a></li><li><a href="/dom/element.html" title="Element 节点">Element 节点</a></li><li><a href="/dom/attributes.html" title="属性的操作">属性的操作</a></li><li><a href="/dom/text.html" title="Text 节点和 DocumentFragment 节点">Text 节点和 DocumentFragment 节点</a></li><li><a href="/dom/mutationobserver.html" title="Mutation Observer API">Mutation Observer API</a></li></ul></li><li><a title="事件">事件<i class="fa fa-angle-down"></i></a><ul><li><a href="/events/eventtarget.html" title="EventTarget 接口">EventTarget 接口</a></li><li><a href="/events/model.html" title="事件模型">事件模型</a></li><li><a href="/events/event.html" title="Event 对象">Event 对象</a></li><li><a href="/events/mouse.html" title="鼠标事件">鼠标事件</a></li><li><a href="/events/keyboard.html" title="键盘事件">键盘事件</a></li><li><a href="/events/progress.html" title="进度事件">进度事件</a></li><li><a href="/events/form.html" title="表单事件">表单事件</a></li><li><a href="/events/touch.html" title="触摸事件">触摸事件</a></li><li><a href="/events/drag.html" title="拖拉事件">拖拉事件</a></li><li><a href="/events/common.html" title="其他常见事件">其他常见事件</a></li><li><a href="/events/globaleventhandlers.html" title="拖拉事件">拖拉事件</a></li></ul></li><li><a title="浏览器模型">浏览器模型<i class="fa fa-angle-down"></i></a><ul><li><a href="/bom/engine.html" title="浏览器环境概述">浏览器环境概述</a></li><li><a href="/bom/window.html" title="window 对象">window 对象</a></li><li><a href="/bom/navigator.html" title="Navigator 对象，Screen 对象">Navigator 对象，Screen 对象</a></li><li><a href="/bom/cookie.html" title="cookie">cookie</a></li><li><a href="/bom/xmlhttprequest.html" title="XMLHttpRequest 对象">XMLHttpRequest 对象</a></li><li><a href="/bom/same-origin.html" title="同源限制">同源限制</a></li><li><a href="/bom/cors.html" title="CORS 通信">CORS 通信</a></li><li><a href="/bom/storage.html" title="Storage 接口">Storage 接口</a></li><li><a href="/bom/history.html" title="History 对象">History 对象</a></li><li><a href="/bom/location.html" title="Location 对象，URL 对象，URLSearchParams 对象">Location 对象，URL 对象，URLSearchParams 对象</a></li><li><a href="/bom/arraybuffer.html" title="ArrayBuffer 对象，Blob 对象">ArrayBuffer 对象，Blob 对象</a></li><li><a href="/bom/file.html" title="File 对象，FileList 对象，FileReader 对象">File 对象，FileList 对象，FileReader 对象</a></li><li><a href="/bom/form.html" title="表单，FormData 对象">表单，FormData 对象</a></li><li><a href="/bom/indexeddb.html" title="IndexedDB API">IndexedDB API</a></li><li><a href="/bom/webworker.html" title="Web Worker">Web Worker</a></li></ul></li><li><a title="附录：网页元素接口">附录：网页元素接口<i class="fa fa-angle-down"></i></a><ul><li><a href="/elements/a.html" title="a 元素">a 元素</a></li><li><a href="/elements/image.html" title="img 元素">img 元素</a></li><li><a href="/elements/form.html" title="form 元素">form 元素</a></li><li><a href="/elements/input.html" title="input 元素">input 元素</a></li><li><a href="/elements/button.html" title="button 元素">button 元素</a></li><li><a href="/elements/option.html" title="option 元素">option 元素</a></li><li><a href="/elements/video.html" title="video，audio">video，audio</a></li></ul></li></ul></li></ul></body></html><div class="tea-version"><p>version: v0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>Node 接口</span></h3></div><div class="tea-container"><div class="markdown-body"><h1><a href="#Node-接口" class="header-anchor">#</a> <span>Node 接口</span></h1><p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p><h2><a href="#属性" class="header-anchor">#</a> <span>属性</span></h2><h3><a href="#Node.prototype.nodeType" class="header-anchor">#</a> <span>Node.prototype.nodeType</span></h3><p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p><pre class="prettyprint language-javascript"><code>document.nodeType // 9</code></pre><p>上面代码中，文档节点的类型值为9。</p><p>Node 对象定义了几个常量，对应这些类型值。</p><pre class="prettyprint language-javascript"><code>document.nodeType === Node.DOCUMENT_NODE // true</code></pre><p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p><p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p><ul><li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li><li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li><li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li><li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li><li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li><li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li><li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li></ul><p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p><pre class="prettyprint language-javascript"><code>var node = document.documentElement.firstChild;
if (node.nodeType === Node.ELEMENT_NODE) {
  console.log(&#039;该节点是元素节点&#039;);
}</code></pre><h3><a href="#Node.prototype.nodeName" class="header-anchor">#</a> <span>Node.prototype.nodeName</span></h3><p><code>nodeName</code>属性返回节点的名称。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById(&#039;d1&#039;);
div.nodeName // &quot;DIV&quot;</code></pre><p>上面代码中，元素节点<code>&lt;div&gt;</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p><p>不同节点的<code>nodeName</code>属性值如下。</p><ul><li>文档节点（document）：<code>#document</code></li><li>元素节点（element）：大写的标签名</li><li>属性节点（attr）：属性的名称</li><li>文本节点（text）：<code>#text</code></li><li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li><li>文档类型节点（DocumentType）：文档的类型</li><li>注释节点（Comment）：<code>#comment</code></li></ul><h3><a href="#Node.prototype.nodeValue" class="header-anchor">#</a> <span>Node.prototype.nodeValue</span></h3><p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p><p>只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这两类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;
var div = document.getElementById(&#039;d1&#039;);
div.nodeValue // null
div.firstChild.nodeValue // &quot;hello world&quot;</code></pre><p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p><h3><a href="#Node.prototype.textContent" class="header-anchor">#</a> <span>Node.prototype.textContent</span></h3><p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p><pre class="prettyprint language-javascript"><code>// HTML 代码为
// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;

document.getElementById(&#039;divA&#039;).textContent
// This is some text</code></pre><p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p><p>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</p><pre class="prettyprint language-javascript"><code>document.getElementById(&#039;foo&#039;).textContent = &#039;&lt;p&gt;GoodBye!&lt;/p&gt;&#039;;</code></pre><p>上面代码在插入文本时，会将<code>&lt;p&gt;</code>标签解释为文本，而不会当作标签处理。</p><p>对于文本节点（text）和注释节点（comment），<code>textContent</code>属性的值与<code>nodeValue</code>属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。</p><p>文档节点（document）和文档类型节点（doctype）的<code>textContent</code>属性为<code>null</code>。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</p><h3><a href="#Node.prototype.baseURI" class="header-anchor">#</a> <span>Node.prototype.baseURI</span></h3><p><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p><pre class="prettyprint language-javascript"><code>// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// &quot;http://www.example.com/index.html&quot;</code></pre><p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p><p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p><pre class="prettyprint language-html"><code>&lt;base href=&quot;http://www.example.com/page.html&quot;&gt;</code></pre><p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p><h3><a href="#Node.prototype.ownerDocument" class="header-anchor">#</a> <span>Node.prototype.ownerDocument</span></h3><p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p><pre class="prettyprint language-javascript"><code>var d = p.ownerDocument;
d === document // true</code></pre><p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p><h3><a href="#Node.prototype.nextSibling" class="header-anchor">#</a> <span>Node.prototype.nextSibling</span></h3><p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;
var div1 = document.getElementById(&#039;d1&#039;);
var div2 = document.getElementById(&#039;d2&#039;);

d1.nextSibling === d2 // true</code></pre><p>上面代码中，<code>d1.nextSibling</code>就是紧跟在<code>d1</code>后面的同级节点<code>d2</code>。</p><p>注意，该属性还包括文本节点和注释节点（<code>&lt;!-- comment --&gt;</code>）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p><p><code>nextSibling</code>属性可以用来遍历所有子节点。</p><pre class="prettyprint language-javascript"><code>var el = document.getElementById(&#039;div1&#039;).firstChild;

while (el !== null) {
  console.log(el.nodeName);
  el = el.nextSibling;
}</code></pre><p>上面代码遍历<code>div1</code>节点的所有子节点。</p><h3><a href="#Node.prototype.previousSibling" class="header-anchor">#</a> <span>Node.prototype.previousSibling</span></h3><p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;
var div1 = document.getElementById(&#039;d1&#039;);
var div2 = document.getElementById(&#039;d2&#039;);

d2.previousSibling === d1 // true</code></pre><p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p><p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p><h3><a href="#Node.prototype.parentNode" class="header-anchor">#</a> <span>Node.prototype.parentNode</span></h3><p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p><pre class="prettyprint language-javascript"><code>if (node.parentNode) {
  node.parentNode.removeChild(node);
}</code></pre><p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p><p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p><h3><a href="#Node.prototype.parentElement" class="header-anchor">#</a> <span>Node.prototype.parentElement</span></h3><p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>if (node.parentElement) {
  node.parentElement.style.color = &#039;red&#039;;
}</code></pre><p>上面代码中，父元素节点的样式设定了红色。</p><p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p><h3><a href="#Node.prototype.firstChild，Node.prototype.lastChild" class="header-anchor">#</a> <span>Node.prototype.firstChild，Node.prototype.lastChild</span></h3><p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回<code>null</code>。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;p id=&quot;p1&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;
var p1 = document.getElementById(&#039;p1&#039;);
p1.firstChild.nodeName // &quot;SPAN&quot;</code></pre><p>上面代码中，<code>p</code>元素的第一个子节点是<code>span</code>元素。</p><p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;p id=&quot;p1&quot;&gt;
//   &lt;span&gt;First span&lt;/span&gt;
//  &lt;/p&gt;
var p1 = document.getElementById(&#039;p1&#039;);
p1.firstChild.nodeName // &quot;#text&quot;</code></pre><p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p><p><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</p><h3><a href="#Node.prototype.childNodes" class="header-anchor">#</a> <span>Node.prototype.childNodes</span></h3><p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p><pre class="prettyprint language-javascript"><code>var children = document.querySelector(&#039;ul&#039;).childNodes;</code></pre><p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p><p>使用该属性，可以遍历某个节点的所有子节点。</p><pre class="prettyprint language-javascript"><code>var div = document.getElementById(&#039;div1&#039;);
var children = div.childNodes;

for (var i = 0; i &lt; children.length; i++) {
  // ...
}</code></pre><p>文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。</p><pre class="prettyprint language-javascript"><code>var children = document.childNodes;
for (var i = 0; i &lt; children.length; i++) {
  console.log(children[i].nodeType);
}
// 10
// 1</code></pre><p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p><p>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</p><h3><a href="#Node.prototype.isConnected" class="header-anchor">#</a> <span>Node.prototype.isConnected</span></h3><p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p><pre class="prettyprint language-javascript"><code>var test = document.createElement(&#039;p&#039;);
test.isConnected // false

document.body.appendChild(test);
test.isConnected // true</code></pre><p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p><h2><a href="#方法" class="header-anchor">#</a> <span>方法</span></h2><h3><a href="#Node.prototype.appendChild()" class="header-anchor">#</a> <span>Node.prototype.appendChild()</span></h3><p><code>appendChild</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p><pre class="prettyprint language-javascript"><code>var p = document.createElement(&#039;p&#039;);
document.body.appendChild(p);</code></pre><p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p><p>如果参数节点是 DOM 已经存在的节点，<code>appendChild</code>方法会将其从原来的位置，移动到新位置。</p><pre class="prettyprint language-javascript"><code>var element = document
  .createElement(&#039;div&#039;)
  .appendChild(document.createElement(&#039;b&#039;));</code></pre><p>上面代码的返回值是<code>&lt;b&gt;&lt;/b&gt;</code>，而不是<code>&lt;div&gt;&lt;/div&gt;</code>。</p><p>如果<code>appendChild</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p><h3><a href="#Node.prototype.hasChildNodes()" class="header-anchor">#</a> <span>Node.prototype.hasChildNodes()</span></h3><p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p><pre class="prettyprint language-javascript"><code>var foo = document.getElementById(&#039;foo&#039;);

if (foo.hasChildNodes()) {
  foo.removeChild(foo.childNodes[0]);
}</code></pre><p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p><p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p><p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p><ul><li><code>node.hasChildNodes()</code></li><li><code>node.firstChild !== null</code></li><li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li></ul><p><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</p><pre class="prettyprint language-javascript"><code>function DOMComb(parent, callback) {
  if (parent.hasChildNodes()) {
    for (var node = parent.firstChild; node; node = node.nextSibling) {
      DOMComb(node, callback);
    }
  }
  callback(parent);
}

// 用法
DOMComb(document.body, console.log)</code></pre><p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p><h3><a href="#Node.prototype.cloneNode()" class="header-anchor">#</a> <span>Node.prototype.cloneNode()</span></h3><p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p><pre class="prettyprint language-javascript"><code>var cloneUL = document.querySelector(&#039;ul&#039;).cloneNode(true);</code></pre><p>该方法有一些使用注意点。</p><p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p><p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p><p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p><h3><a href="#Node.prototype.insertBefore()" class="header-anchor">#</a> <span>Node.prototype.insertBefore()</span></h3><p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p><pre class="prettyprint language-javascript"><code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</code></pre><p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p><pre class="prettyprint language-javascript"><code>var p = document.createElement(&#039;p&#039;);
document.body.insertBefore(p, document.body.firstChild);</code></pre><p>上面代码中，新建一个<code>&lt;p&gt;</code>节点，插在<code>document.body.firstChild</code>的前面，也就是成为<code>document.body</code>的第一个子节点。</p><p>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</p><pre class="prettyprint language-javascript"><code>var p = document.createElement(&#039;p&#039;);
document.body.insertBefore(p, null);</code></pre><p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p><p>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</p><p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p><pre class="prettyprint language-javascript"><code>parent.insertBefore(s1, s2.nextSibling);</code></pre><p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p><p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p><h3><a href="#Node.prototype.removeChild()" class="header-anchor">#</a> <span>Node.prototype.removeChild()</span></h3><p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p><pre class="prettyprint language-javascript"><code>var divA = document.getElementById(&#039;A&#039;);
divA.parentNode.removeChild(divA);</code></pre><p>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</p><p>下面是如何移除当前节点的所有子节点。</p><pre class="prettyprint language-javascript"><code>var element = document.getElementById(&#039;top&#039;);
while (element.firstChild) {
  element.removeChild(element.firstChild);
}</code></pre><p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p><p>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</p><h3><a href="#Node.prototype.replaceChild()" class="header-anchor">#</a> <span>Node.prototype.replaceChild()</span></h3><p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p><pre class="prettyprint language-javascript"><code>var replacedNode = parentNode.replaceChild(newChild, oldChild);</code></pre><p>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</p><pre class="prettyprint language-javascript"><code>var divA = document.getElementById(&#039;divA&#039;);
var newSpan = document.createElement(&#039;span&#039;);
newSpan.textContent = &#039;Hello World!&#039;;
divA.parentNode.replaceChild(newSpan, divA);</code></pre><p>上面代码是如何将指定节点<code>divA</code>替换走。</p><h3><a href="#Node.prototype.contains()" class="header-anchor">#</a> <span>Node.prototype.contains()</span></h3><p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p><ul><li>参数节点为当前节点。</li><li>参数节点为当前节点的子节点。</li><li>参数节点为当前节点的后代节点。</li></ul><pre class="prettyprint language-javascript"><code>document.body.contains(node)</code></pre><p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p><p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p><pre class="prettyprint language-javascript"><code>nodeA.contains(nodeA) // true</code></pre><h3><a href="#Node.prototype.compareDocumentPosition()" class="header-anchor">#</a> <span>Node.prototype.compareDocumentPosition()</span></h3><p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</p><table><thead><tr><th>二进制值</th><th>十进制值</th><th>含义</th></tr></thead><tbody><tr><td>000000</td><td>0</td><td>两个节点相同</td></tr><tr><td>000001</td><td>1</td><td>两个节点不在同一个文档（即有一个节点不在当前文档）</td></tr><tr><td>000010</td><td>2</td><td>参数节点在当前节点的前面</td></tr><tr><td>000100</td><td>4</td><td>参数节点在当前节点的后面</td></tr><tr><td>001000</td><td>8</td><td>参数节点包含当前节点</td></tr><tr><td>010000</td><td>16</td><td>当前节点包含参数节点</td></tr><tr><td>100000</td><td>32</td><td>浏览器内部使用</td></tr></tbody></table><pre class="prettyprint language-javascript"><code>// HTML 代码如下
// &lt;div id=&quot;mydiv&quot;&gt;
//   &lt;form&gt;&lt;input id=&quot;test&quot; /&gt;&lt;/form&gt;
// &lt;/div&gt;

var div = document.getElementById(&#039;mydiv&#039;);
var input = document.getElementById(&#039;test&#039;);

div.compareDocumentPosition(input) // 20
input.compareDocumentPosition(div) // 10</code></pre><p>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</p><p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p><pre class="prettyprint language-javascript"><code>var head = document.head;
var body = document.body;
if (head.compareDocumentPosition(body) &amp; 4) {
  console.log(&#039;文档结构正确&#039;);
} else {
  console.log(&#039;&lt;body&gt; 不能在 &lt;head&gt; 前面&#039;);
}</code></pre><p>上面代码中，<code>compareDocumentPosition</code>的返回值与<code>4</code>（又称掩码）进行与运算（<code>&amp;</code>），得到一个布尔值，表示<code>&lt;head&gt;</code>是否在<code>&lt;body&gt;</code>前面。</p><h3><a href="#Node.prototype.isEqualNode()，Node.prototype.isSameNode()" class="header-anchor">#</a> <span>Node.prototype.isEqualNode()，Node.prototype.isSameNode()</span></h3><p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p><pre class="prettyprint language-javascript"><code>var p1 = document.createElement(&#039;p&#039;);
var p2 = document.createElement(&#039;p&#039;);

p1.isEqualNode(p2) // true</code></pre><p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p><pre class="prettyprint language-javascript"><code>var p1 = document.createElement(&#039;p&#039;);
var p2 = document.createElement(&#039;p&#039;);

p1.isSameNode(p2) // false
p1.isSameNode(p1) // true</code></pre><h3><a href="#Node.prototype.normalize()" class="header-anchor">#</a> <span>Node.prototype.normalize()</span></h3><p><code>normailize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p><pre class="prettyprint language-javascript"><code>var wrapper = document.createElement(&#039;div&#039;);

wrapper.appendChild(document.createTextNode(&#039;Part 1 &#039;));
wrapper.appendChild(document.createTextNode(&#039;Part 2 &#039;));

wrapper.childNodes.length // 2
wrapper.normalize();
wrapper.childNodes.length // 1</code></pre><p>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</p><p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p><h3><a href="#Node.prototype.getRootNode()" class="header-anchor">#</a> <span>Node.prototype.getRootNode()</span></h3><p><code>getRootNode</code>方法返回当前节点所在文档的根节点，与<code>ownerDocument</code>属性的作用相同。</p><pre class="prettyprint language-javascript"><code>document.body.firstChild.getRootNode() === document
// true
document.body.firstChild.getRootNode() === document.body.firstChild.ownerDocument
// true</code></pre></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script></body></html>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
