<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="description" content="欢迎使用Teadocs文档生成系统"><meta name="keywords" content="teadocs, 文档生成器"><title>数组 - 阮一峰的JavaScript教程</title><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script src="https://cdn.bootcss.com/socket.io/2.1.1/socket.io.js"></script><script>window._CONST={THEME_DIR:"{{_CONST.THEME_DIR}}"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>阮一峰的JavaScript教程</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value="" height="100%"></div><html><head></head><body><ul class="tea-menu-list"><li><a href="/index.html" title="关于" class="">关于</a></li><li><a href="/preface.html" title="阮一峰前言" class="">阮一峰前言</a></li><li><a title="教程" class="active">教程<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="入门篇" class="">入门篇<i class="fa fa-angle-down"></i></a><ul><li><a href="/basic/introduction.html" title="导论" class="">导论</a></li><li><a href="/basic/history.html" title="历史" class="">历史</a></li><li><a href="/basic/grammar.html" title="基本语法" class="">基本语法</a></li></ul></li><li><a title="数据类型" class="active">数据类型<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/types/general.html" title="概述" class="">概述</a></li><li><a href="/types/null-undefined-boolean.html" title="null，undefined和布尔值" class="">null，undefined和布尔值</a></li><li><a href="/types/number.html" title="数值" class="">数值</a></li><li><a href="/types/string.html" title="字符串" class="">字符串</a></li><li><a href="/types/object.html" title="对象" class="">对象</a></li><li><a href="/types/function.html" title="函数" class="">函数</a></li><li><a href="/types/array.html" title="数组" class="active">数组</a></li></ul></li><li><a title="运算符">运算符<i class="fa fa-angle-down"></i></a><ul><li><a href="/operators/arithmetic.html" title="算术运算符">算术运算符</a></li><li><a href="/operators/comparison.html" title="比较运算符">比较运算符</a></li><li><a href="/operators/boolean.html" title="布尔运算符">布尔运算符</a></li><li><a href="/operators/bit.html" title="二进制位运算符">二进制位运算符</a></li><li><a href="/operators/priority.html" title="其他运算符，运算顺序">其他运算符，运算顺序</a></li></ul></li><li><a title="语法专题">语法专题<i class="fa fa-angle-down"></i></a><ul><li><a href="/features/conversion.html" title="数据类型的转换">数据类型的转换</a></li><li><a href="/features/error.html" title="错误处理机制">错误处理机制</a></li><li><a href="/features/style.html" title="编程风格">编程风格</a></li><li><a href="/features/console.html" title="console 对象与控制台">console 对象与控制台</a></li></ul></li><li><a title="标准库">标准库<i class="fa fa-angle-down"></i></a><ul><li><a href="/stdlib/object.html" title="Object对象">Object对象</a></li><li><a href="/stdlib/attributes.html" title="属性描述对象">属性描述对象</a></li><li><a href="/stdlib/array.html" title="Array 对象">Array 对象</a></li><li><a href="/stdlib/wrapper.html" title="包装对象">包装对象</a></li><li><a href="/stdlib/boolean.html" title="Boolean 对象">Boolean 对象</a></li><li><a href="/stdlib/number.html" title="Number 对象">Number 对象</a></li><li><a href="/stdlib/string.html" title="String 对象">String 对象</a></li><li><a href="/stdlib/math.html" title="Math 对象">Math 对象</a></li><li><a href="/stdlib/date.html" title="Date 对象">Date 对象</a></li><li><a href="/stdlib/regexp.html" title="RegExp 对象">RegExp 对象</a></li><li><a href="/stdlib/json.html" title="JSON 对象">JSON 对象</a></li></ul></li><li><a title="面向对象编程">面向对象编程<i class="fa fa-angle-down"></i></a><ul><li><a href="/oop/new.html" title="实例对象与 new 命令">实例对象与 new 命令</a></li><li><a href="/oop/this.html" title="this 关键字">this 关键字</a></li><li><a href="/oop/prototype.html" title="对象的继承">对象的继承</a></li><li><a href="/oop/object.html" title="Object 对象的相关方法">Object 对象的相关方法</a></li><li><a href="/oop/strict.html" title="Object 对象的相关方法">Object 对象的相关方法</a></li></ul></li><li><a title="异步操作">异步操作<i class="fa fa-angle-down"></i></a><ul><li><a href="/async/general.html" title="概述">概述</a></li><li><a href="/async/timer.html" title="定时器">定时器</a></li><li><a href="/async/promise.html" title="Promise 对象">Promise 对象</a></li></ul></li><li><a title="DOM">DOM<i class="fa fa-angle-down"></i></a><ul><li><a href="/dom/general.html" title="概述">概述</a></li><li><a href="/dom/node.html" title="Node 接口">Node 接口</a></li><li><a href="/dom/nodelist.html" title="NodeList 接口，HTMLCollection 接口">NodeList 接口，HTMLCollection 接口</a></li><li><a href="/dom/parentnode.html" title="ParentNode 接口，ChildNode 接口">ParentNode 接口，ChildNode 接口</a></li><li><a href="/dom/document.html" title="Document 节点">Document 节点</a></li><li><a href="/dom/element.html" title="Element 节点">Element 节点</a></li><li><a href="/dom/attributes.html" title="属性的操作">属性的操作</a></li><li><a href="/dom/text.html" title="Text 节点和 DocumentFragment 节点">Text 节点和 DocumentFragment 节点</a></li><li><a href="/dom/mutationobserver.html" title="Mutation Observer API">Mutation Observer API</a></li></ul></li><li><a title="事件">事件<i class="fa fa-angle-down"></i></a><ul><li><a href="/events/eventtarget.html" title="EventTarget 接口">EventTarget 接口</a></li><li><a href="/events/model.html" title="事件模型">事件模型</a></li><li><a href="/events/event.html" title="Event 对象">Event 对象</a></li><li><a href="/events/mouse.html" title="鼠标事件">鼠标事件</a></li><li><a href="/events/keyboard.html" title="键盘事件">键盘事件</a></li><li><a href="/events/progress.html" title="进度事件">进度事件</a></li><li><a href="/events/form.html" title="表单事件">表单事件</a></li><li><a href="/events/touch.html" title="触摸事件">触摸事件</a></li><li><a href="/events/drag.html" title="拖拉事件">拖拉事件</a></li><li><a href="/events/common.html" title="其他常见事件">其他常见事件</a></li><li><a href="/events/globaleventhandlers.html" title="拖拉事件">拖拉事件</a></li></ul></li><li><a title="浏览器模型">浏览器模型<i class="fa fa-angle-down"></i></a><ul><li><a href="/bom/engine.html" title="浏览器环境概述">浏览器环境概述</a></li><li><a href="/bom/window.html" title="window 对象">window 对象</a></li><li><a href="/bom/navigator.html" title="Navigator 对象，Screen 对象">Navigator 对象，Screen 对象</a></li><li><a href="/bom/cookie.html" title="cookie">cookie</a></li><li><a href="/bom/xmlhttprequest.html" title="XMLHttpRequest 对象">XMLHttpRequest 对象</a></li><li><a href="/bom/same-origin.html" title="同源限制">同源限制</a></li><li><a href="/bom/cors.html" title="CORS 通信">CORS 通信</a></li><li><a href="/bom/storage.html" title="Storage 接口">Storage 接口</a></li><li><a href="/bom/history.html" title="History 对象">History 对象</a></li><li><a href="/bom/location.html" title="Location 对象，URL 对象，URLSearchParams 对象">Location 对象，URL 对象，URLSearchParams 对象</a></li><li><a href="/bom/arraybuffer.html" title="ArrayBuffer 对象，Blob 对象">ArrayBuffer 对象，Blob 对象</a></li><li><a href="/bom/file.html" title="File 对象，FileList 对象，FileReader 对象">File 对象，FileList 对象，FileReader 对象</a></li><li><a href="/bom/form.html" title="表单，FormData 对象">表单，FormData 对象</a></li><li><a href="/bom/indexeddb.html" title="IndexedDB API">IndexedDB API</a></li><li><a href="/bom/webworker.html" title="Web Worker">Web Worker</a></li></ul></li><li><a title="附录：网页元素接口">附录：网页元素接口<i class="fa fa-angle-down"></i></a><ul><li><a href="/elements/a.html" title="a 元素">a 元素</a></li><li><a href="/elements/image.html" title="img 元素">img 元素</a></li><li><a href="/elements/form.html" title="form 元素">form 元素</a></li><li><a href="/elements/input.html" title="input 元素">input 元素</a></li><li><a href="/elements/button.html" title="button 元素">button 元素</a></li><li><a href="/elements/option.html" title="option 元素">option 元素</a></li><li><a href="/elements/video.html" title="video，audio">video，audio</a></li></ul></li></ul></li></ul></body></html><div class="tea-version"><p>version: v0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>数组</span></h3></div><div class="tea-container"><div class="markdown-body"><h1><a href="#数组" class="header-anchor">#</a> <span>数组</span></h1><h2><a href="#定义" class="header-anchor">#</a> <span>定义</span></h2><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p><pre class="prettyprint language-javascript"><code>var arr = [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;];</code></pre><p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置。</p><p>除了在定义时赋值，数组也可以先定义后赋值。</p><pre class="prettyprint language-javascript"><code>var arr = [];

arr[0] = &#039;a&#039;;
arr[1] = &#039;b&#039;;
arr[2] = &#039;c&#039;;</code></pre><p>任何类型的数据，都可以放入数组。</p><pre class="prettyprint language-javascript"><code>var arr = [
  {a: 1},
  [1, 2, 3],
  function() {return true;}
];

arr[0] // Object {a: 1}
arr[1] // [1, 2, 3]
arr[2] // function (){return true;}</code></pre><p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数。</p><p>如果数组的元素还是数组，就形成了多维数组。</p><pre class="prettyprint language-javascript"><code>var a = [[1, 2], [3, 4]];
a[0][1] // 2
a[1][1] // 4</code></pre><h2><a href="#数组的本质" class="header-anchor">#</a> <span>数组的本质</span></h2><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p><pre class="prettyprint language-javascript"><code>typeof [1, 2, 3] // &quot;object&quot;</code></pre><p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象。</p><p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2...）。</p><pre class="prettyprint language-javascript"><code>var arr = [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;];

Object.keys(arr)
// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</code></pre><p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p><p>由于数组成员的键名是固定的（默认总是0、1、2...），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p><pre class="prettyprint language-javascript"><code>var arr = [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;];

arr[&#039;0&#039;] // &#039;a&#039;
arr[0] // &#039;a&#039;</code></pre><p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p><p>注意，这点在赋值时也成立。如果一个值总是先转成字符串，再进行赋值。</p><pre class="prettyprint language-javascript"><code>var a = [];

a[1.00] = 6;
a[1] // 6</code></pre><p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p><p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p><pre class="prettyprint language-javascript"><code>var arr = [1, 2, 3];
arr.0 // SyntaxError</code></pre><p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p><h2><a href="#length-属性" class="header-anchor">#</a> <span>length 属性</span></h2><p>数组的<code>length</code>属性，返回数组的成员数量。</p><pre class="prettyprint language-javascript"><code>[&#039;a&#039;, &#039;b&#039;, &#039;c&#039;].length // 3</code></pre><p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2<sup>32</sup> - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p><p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p><pre class="prettyprint language-javascript"><code>var arr = [&#039;a&#039;, &#039;b&#039;];
arr.length // 2

arr[2] = &#039;c&#039;;
arr.length // 3

arr[9] = &#039;d&#039;;
arr.length // 10

arr[1000] = &#039;e&#039;;
arr.length // 1001</code></pre><p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p><p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到<code>length</code>设置的值。</p><pre class="prettyprint language-javascript"><code>var arr = [ &#039;a&#039;, &#039;b&#039;, &#039;c&#039; ];
arr.length // 3

arr.length = 2;
arr // [&quot;a&quot;, &quot;b&quot;]</code></pre><p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了。</p><p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p><pre class="prettyprint language-javascript"><code>var arr = [ &#039;a&#039;, &#039;b&#039;, &#039;c&#039; ];

arr.length = 0;
arr // []</code></pre><p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p><pre class="prettyprint language-javascript"><code>var a = [&#039;a&#039;];

a.length = 3;
a[1] // undefined</code></pre><p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p><p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错。</p><pre class="prettyprint language-javascript"><code>// 设置负值
[].length = -1
// RangeError: Invalid array length

// 数组元素个数大于等于2的32次方
[].length = Math.pow(2, 32)
// RangeError: Invalid array length

// 设置字符串
[].length = &#039;abc&#039;
// RangeError: Invalid array length</code></pre><p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p><pre class="prettyprint language-javascript"><code>var a = [];

a[&#039;p&#039;] = &#039;abc&#039;;
a.length // 0

a[2.1] = &#039;abc&#039;;
a.length // 0</code></pre><p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p><p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。</p><pre class="prettyprint language-javascript"><code>var arr = [];
arr[-1] = &#039;a&#039;;
arr[Math.pow(2, 32)] = &#039;b&#039;;

arr.length // 0
arr[-1] // &quot;a&quot;
arr[4294967296] // &quot;b&quot;</code></pre><p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p><h2><a href="#in-运算符" class="header-anchor">#</a> <span>in 运算符</span></h2><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p><pre class="prettyprint language-javascript"><code>var arr = [ &#039;a&#039;, &#039;b&#039;, &#039;c&#039; ];
2 in arr  // true
&#039;2&#039; in arr // true
4 in arr // false</code></pre><p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p><p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p><pre class="prettyprint language-javascript"><code>var arr = [];
arr[100] = &#039;a&#039;;

100 in arr // true
1 in arr // false</code></pre><p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p><h2><a href="#for...in-循环和数组的遍历" class="header-anchor">#</a> <span>for...in 循环和数组的遍历</span></h2><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p><pre class="prettyprint language-javascript"><code>var a = [1, 2, 3];

for (var i in a) {
  console.log(a[i]);
}
// 1
// 2
// 3</code></pre><p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p><pre class="prettyprint language-javascript"><code>var a = [1, 2, 3];
a.foo = true;

for (var key in a) {
  console.log(key);
}
// 0
// 1
// 2
// foo</code></pre><p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组。</p><p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p><pre class="prettyprint language-javascript"><code>var a = [1, 2, 3];

// for循环
for(var i = 0; i &lt; a.length; i++) {
  console.log(a[i]);
}

// while循环
var i = 0;
while (i &lt; a.length) {
  console.log(a[i]);
  i++;
}

var l = a.length;
while (l--) {
  console.log(a[l]);
}</code></pre><p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p><p>数组的<code>forEach</code>方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。</p><pre class="prettyprint language-javascript"><code>var colors = [&#039;red&#039;, &#039;green&#039;, &#039;blue&#039;];
colors.forEach(function (color) {
  console.log(color);
});
// red
// green
// blue</code></pre><h2><a href="#数组的空位" class="header-anchor">#</a> <span>数组的空位</span></h2><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p><pre class="prettyprint language-javascript"><code>var a = [1, , 1];
a.length // 3</code></pre><p>上面代码表明，数组的空位不影响<code>length</code>属性。</p><p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p><pre class="prettyprint language-javascript"><code>var a = [1, 2, 3,];

a.length // 3
a // [1, 2, 3]</code></pre><p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p><p>数组的空位是可以读取的，返回<code>undefined</code>。</p><pre class="prettyprint language-javascript"><code>var a = [, , ,];
a[1] // undefined</code></pre><p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p><pre class="prettyprint language-javascript"><code>var a = [1, 2, 3];
delete a[1];

a[1] // undefined
a.length // 3</code></pre><p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p><p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p><pre class="prettyprint language-javascript"><code>var a = [, , ,];

a.forEach(function (x, i) {
  console.log(i + &#039;. &#039; + x);
})
// 不产生任何输出

for (var i in a) {
  console.log(i);
}
// 不产生任何输出

Object.keys(a)
// []</code></pre><p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p><pre class="prettyprint language-javascript"><code>var a = [undefined, undefined, undefined];

a.forEach(function (x, i) {
  console.log(i + &#039;. &#039; + x);
});
// 0. undefined
// 1. undefined
// 2. undefined

for (var i in a) {
  console.log(i);
}
// 0
// 1
// 2

Object.keys(a)
// [&#039;0&#039;, &#039;1&#039;, &#039;2&#039;]</code></pre><p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p><h2><a href="#类似数组的对象" class="header-anchor">#</a> <span>类似数组的对象</span></h2><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p><pre class="prettyprint language-javascript"><code>var obj = {
  0: &#039;a&#039;,
  1: &#039;b&#039;,
  2: &#039;c&#039;,
  length: 3
};

obj[0] // &#039;a&#039;
obj[1] // &#039;b&#039;
obj.length // 3
obj.push(&#039;d&#039;) // TypeError: obj.push is not a function</code></pre><p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p><p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p><pre class="prettyprint language-javascript"><code>var obj = {
  length: 0
};
obj[3] = &#039;d&#039;;
obj.length // 0</code></pre><p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p><p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p><pre class="prettyprint language-javascript"><code>// arguments对象
function args() { return arguments }
var arrayLike = args(&#039;a&#039;, &#039;b&#039;);

arrayLike[0] // &#039;a&#039;
arrayLike.length // 2
arrayLike instanceof Array // false

// DOM元素集
var elts = document.getElementsByTagName(&#039;h3&#039;);
elts.length // 3
elts instanceof Array // false

// 字符串
&#039;abc&#039;[1] // &#039;b&#039;
&#039;abc&#039;.length // 3
&#039;abc&#039; instanceof Array // false</code></pre><p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p><p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p><pre class="prettyprint language-javascript"><code>var arr = Array.prototype.slice.call(arrayLike);</code></pre><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p><pre class="prettyprint language-javascript"><code>function print(value, index) {
  console.log(index + &#039; : &#039; + value);
}

Array.prototype.forEach.call(arrayLike, print);</code></pre><p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p><p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p><pre class="prettyprint language-javascript"><code>// forEach 方法
function logArgs() {
  Array.prototype.forEach.call(arguments, function (elem, i) {
    console.log(i + &#039;. &#039; + elem);
  });
}

// 等同于 for 循环
function logArgs() {
  for (var i = 0; i &lt; arguments.length; i++) {
    console.log(i + &#039;. &#039; + arguments[i]);
  }
}</code></pre><p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p><pre class="prettyprint language-javascript"><code>Array.prototype.forEach.call(&#039;abc&#039;, function (chr) {
  console.log(chr);
});
// a
// b
// c</code></pre><p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p><pre class="prettyprint language-javascript"><code>var arr = Array.prototype.slice.call(&#039;abc&#039;);
arr.forEach(function (chr) {
  console.log(chr);
});
// a
// b
// c</code></pre><h2><a href="#参考链接" class="header-anchor">#</a> <span>参考链接</span></h2><ul><li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/12/arrays.html">Arrays in JavaScript</a></li><li>Axel Rauschmayer, <a href="http://www.2ality.com/2012/06/dense-arrays.html">JavaScript: sparse arrays vs. dense arrays</a></li><li>Felix Bohm, <a href="http://net.tutsplus.com/tutorials/javascript-ajax/what-they-didnt-tell-you-about-es5s-array-extras/">What They Didn’t Tell You About ES5′s Array Extras</a></li><li>Juriy Zaytsev, <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">How ECMAScript 5 still does not allow to subclass an array</a></li></ul></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script></body></html>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
